export function adjustCaretPosition({ previousConformedValue = '', previousPlaceholder = '', currentCaretPosition = 0, conformedValue, rawValue, placeholderChar, placeholder, indexesOfPipedChars = [], caretTrapIndexes = [] }) {
    if (currentCaretPosition === 0 || !rawValue.length) {
        return 0;
    }
    // Store lengths for faster performance?
    const rawValueLength = rawValue.length;
    const previousConformedValueLength = previousConformedValue.length;
    const placeholderLength = placeholder.length;
    const conformedValueLength = conformedValue.length;
    // This tells us how long the edit is. If user modified input from `(2__)` to `(243__)`,
    // we know the user in this instance pasted two characters
    const editLength = rawValueLength - previousConformedValueLength;
    // If the edit length is positive, that means the user is adding characters, not deleting.
    const isAddition = editLength > 0;
    // This is the first raw value the user entered that needs to be conformed to mask
    const isFirstRawValue = previousConformedValueLength === 0;
    // A partial multi-character edit happens when the user makes a partial selection in their
    // input and edits that selection. That is going from `(123) 432-4348` to `() 432-4348` by
    // selecting the first 3 digits and pressing backspace.
    //
    // Such cases can also happen when the user presses the backspace while holding down the ALT
    // key.
    const isPartialMultiCharEdit = editLength > 1 && !isAddition && !isFirstRawValue;
    // This algorithm doesn't support all cases of multi-character edits, so we just return
    // the current caret position.
    //
    // This works fine for most cases.
    if (isPartialMultiCharEdit) {
        return currentCaretPosition;
    }
    // For a mask like (111), if the `previousConformedValue` is (1__) and user attempts to enter
    // `f` so the `rawValue` becomes (1f__), the new `conformedValue` would be (1__), which is the
    // same as the original `previousConformedValue`. We handle this case differently for caret
    // positioning.
    const possiblyHasRejectedChar = isAddition && (previousConformedValue === conformedValue ||
        conformedValue === placeholder);
    let startingSearchIndex = 0;
    let trackRightCharacter;
    let targetChar = '';
    if (possiblyHasRejectedChar) {
        startingSearchIndex = currentCaretPosition - editLength;
    }
    else {
        // At this point in the algorithm, we want to know where the caret is right before the raw input
        // has been conformed, and then see if we can find that same spot in the conformed input.
        //
        // We do that by seeing what character lies immediately before the caret, and then look for that
        // same character in the conformed input and place the caret there.
        // First, we need to normalize the inputs so that letter capitalization between raw input and
        // conformed input wouldn't matter.
        const normalizedConformedValue = conformedValue.toLowerCase();
        const normalizedRawValue = rawValue.toLowerCase();
        // Then we take all characters that come before where the caret currently is.
        const leftHalfChars = normalizedRawValue.substr(0, currentCaretPosition).split('');
        // Now we find all the characters in the left half that exist in the conformed input
        // This step ensures that we don't look for a character that was filtered out or rejected by `conformToMask`.
        const intersection = leftHalfChars.filter((char) => normalizedConformedValue.indexOf(char) !== -1);
        // The last character in the intersection is the character we want to look for in the conformed
        // value and the one we want to adjust the caret close to
        targetChar = intersection[intersection.length - 1];
        // Calculate the number of mask characters in the previous placeholder
        // from the start of the string up to the place where the caret is
        const previousLeftMaskChars = previousPlaceholder
            .substr(0, intersection.length)
            .split('')
            .filter(char => char !== placeholderChar)
            .length;
        // Calculate the number of mask characters in the current placeholder
        // from the start of the string up to the place where the caret is
        const leftMaskChars = placeholder
            .substr(0, intersection.length)
            .split('')
            .filter(char => char !== placeholderChar)
            .length;
        // Has the number of mask characters up to the caret changed?
        const masklengthChanged = leftMaskChars !== previousLeftMaskChars;
        // Detect if `targetChar` is a mask character and has moved to the left
        const targetIsMaskMovingLeft = (previousPlaceholder[intersection.length - 1] !== undefined &&
            placeholder[intersection.length - 2] !== undefined &&
            previousPlaceholder[intersection.length - 1] !== placeholderChar &&
            previousPlaceholder[intersection.length - 1] !== placeholder[intersection.length - 1] &&
            previousPlaceholder[intersection.length - 1] === placeholder[intersection.length - 2]);
        // If deleting and the `targetChar` `is a mask character and `masklengthChanged` is true
        // or the mask is moving to the left, we can't use the selected `targetChar` any longer
        // if we are not at the end of the string.
        // In this case, change tracking strategy and track the character to the right of the caret.
        if (!isAddition &&
            (masklengthChanged || targetIsMaskMovingLeft) &&
            previousLeftMaskChars > 0 &&
            placeholder.indexOf(targetChar) > -1 &&
            rawValue[currentCaretPosition] !== undefined) {
            trackRightCharacter = true;
            targetChar = rawValue[currentCaretPosition];
        }
        // It is possible that `targetChar` will appear multiple times in the conformed value.
        // We need to know not to select a character that looks like our target character from the placeholder or
        // the piped characters, so we inspect the piped characters and the placeholder to see if they contain
        // characters that match our target character.
        // If the `conformedValue` got piped, we need to know which characters were piped in so that when we look for
        // our `targetChar`, we don't select a piped char by mistake
        const pipedChars = indexesOfPipedChars.map((index) => normalizedConformedValue[index]);
        // We need to know how many times the `targetChar` occurs in the piped characters.
        const countTargetCharInPipedChars = pipedChars.filter((char) => char === targetChar).length;
        // We need to know how many times it occurs in the intersection
        const countTargetCharInIntersection = intersection.filter((char) => char === targetChar).length;
        // We need to know if the placeholder contains characters that look like
        // our `targetChar`, so we don't select one of those by mistake.
        const countTargetCharInPlaceholder = placeholder
            .substr(0, placeholder.indexOf(placeholderChar))
            .split('')
            .filter((char, index) => (
        // Check if `char` is the same as our `targetChar`, so we account for it
        char === targetChar &&
            // but also make sure that both the `rawValue` and placeholder don't have the same character at the same
            // index because if they are equal, that means we are already counting those characters in
            // `countTargetCharInIntersection`
            rawValue[index] !== char))
            .length;
        // The number of times we need to see occurrences of the `targetChar` before we know it is the one we're looking
        // for is:
        const requiredNumberOfMatches = (countTargetCharInPlaceholder +
            countTargetCharInIntersection +
            countTargetCharInPipedChars +
            // The character to the right of the caret isn't included in `intersection`
            // so add one if we are tracking the character to the right
            (trackRightCharacter ? 1 : 0));
        // Now we start looking for the location of the `targetChar`.
        // We keep looping forward and store the index in every iteration. Once we have encountered
        // enough occurrences of the target character, we break out of the loop
        // If are searching for the second `1` in `1214`, `startingSearchIndex` will point at `4`.
        let numberOfEncounteredMatches = 0;
        for (let i = 0; i < conformedValueLength; i++) {
            const conformedValueChar = normalizedConformedValue[i];
            startingSearchIndex = i + 1;
            if (conformedValueChar === targetChar) {
                numberOfEncounteredMatches++;
            }
            if (numberOfEncounteredMatches >= requiredNumberOfMatches) {
                break;
            }
        }
    }
    // At this point, if we simply return `startingSearchIndex` as the adjusted caret position,
    // most cases would be handled. However, we want to fast forward or rewind the caret to the
    // closest placeholder character if it happens to be in a non-editable spot. That's what the next
    // logic is for.
    // In case of addition, we fast forward.
    if (isAddition) {
        // We want to remember the last placeholder character encountered so that if the mask
        // contains more characters after the last placeholder character, we don't forward the caret
        // that far to the right. Instead, we stop it at the last encountered placeholder character.
        let lastPlaceholderChar = startingSearchIndex;
        for (let i = startingSearchIndex; i <= placeholderLength; i++) {
            if (placeholder[i] === placeholderChar) {
                lastPlaceholderChar = i;
            }
            if (
            // If we're adding, we can position the caret at the next placeholder character.
            placeholder[i] === placeholderChar ||
                // If a caret trap was set by a mask function, we need to stop at the trap.
                caretTrapIndexes.indexOf(i) !== -1 ||
                // This is the end of the placeholder. We cannot move any further. Let's put the caret there.
                i === placeholderLength) {
                return lastPlaceholderChar;
            }
        }
    }
    else {
        // In case of deletion, we rewind.
        if (trackRightCharacter) {
            // Searching for the character that was to the right of the caret
            // We start at `startingSearchIndex` - 1 because it includes one character extra to the right
            for (let i = startingSearchIndex - 1; i >= 0; i--) {
                // If tracking the character to the right of the cursor, we move to the left until
                // we found the character and then place the caret right before it
                if (
                // `targetChar` should be in `conformedValue`, since it was in `rawValue`, just
                // to the right of the caret
                conformedValue[i] === targetChar ||
                    // If a caret trap was set by a mask function, we need to stop at the trap.
                    caretTrapIndexes.indexOf(i) !== -1 ||
                    // This is the beginning of the placeholder. We cannot move any further.
                    // Let's put the caret there.
                    i === 0) {
                    return i;
                }
            }
        }
        else {
            // Searching for the first placeholder or caret trap to the left
            for (let i = startingSearchIndex; i >= 0; i--) {
                // If we're deleting, we stop the caret right before the placeholder character.
                // For example, for mask `(111) 11`, current conformed input `(456) 86`. If user
                // modifies input to `(456 86`. That is, they deleted the `)`, we place the caret
                // right after the first `6`
                if (
                // If we're deleting, we can position the caret right before the placeholder character
                placeholder[i - 1] === placeholderChar ||
                    // If a caret trap was set by a mask function, we need to stop at the trap.
                    caretTrapIndexes.indexOf(i) !== -1 ||
                    // This is the beginning of the placeholder. We cannot move any further.
                    // Let's put the caret there.
                    i === 0) {
                    return i;
                }
            }
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWRqdXN0Q2FyZXRQb3NpdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvY29yZS9hZGp1c3RDYXJldFBvc2l0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLE1BQU0sVUFBVSxtQkFBbUIsQ0FBQyxFQUNsQyxzQkFBc0IsR0FBRyxFQUFFLEVBQzNCLG1CQUFtQixHQUFHLEVBQUUsRUFDeEIsb0JBQW9CLEdBQUcsQ0FBQyxFQUN4QixjQUFjLEVBQ2QsUUFBUSxFQUNSLGVBQWUsRUFDZixXQUFXLEVBQ1gsbUJBQW1CLEdBQUcsRUFBRSxFQUN4QixnQkFBZ0IsR0FBRyxFQUFFLEVBQ1Q7SUFDWixJQUFJLG9CQUFvQixLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQUMsQ0FBQztJQUVqRSx3Q0FBd0M7SUFDeEMsTUFBTSxjQUFjLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQztJQUN2QyxNQUFNLDRCQUE0QixHQUFHLHNCQUFzQixDQUFDLE1BQU0sQ0FBQztJQUNuRSxNQUFNLGlCQUFpQixHQUFHLFdBQVcsQ0FBQyxNQUFNLENBQUM7SUFDN0MsTUFBTSxvQkFBb0IsR0FBRyxjQUFjLENBQUMsTUFBTSxDQUFDO0lBRW5ELHdGQUF3RjtJQUN4RiwwREFBMEQ7SUFDMUQsTUFBTSxVQUFVLEdBQUcsY0FBYyxHQUFHLDRCQUE0QixDQUFDO0lBRWpFLDBGQUEwRjtJQUMxRixNQUFNLFVBQVUsR0FBRyxVQUFVLEdBQUcsQ0FBQyxDQUFDO0lBRWxDLGtGQUFrRjtJQUNsRixNQUFNLGVBQWUsR0FBRyw0QkFBNEIsS0FBSyxDQUFDLENBQUM7SUFFM0QsMEZBQTBGO0lBQzFGLDBGQUEwRjtJQUMxRix1REFBdUQ7SUFDdkQsRUFBRTtJQUNGLDRGQUE0RjtJQUM1RixPQUFPO0lBQ1AsTUFBTSxzQkFBc0IsR0FBRyxVQUFVLEdBQUcsQ0FBQyxJQUFJ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LElBQUksQ0FBQyxHQUFHLG1CQUFtQixFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztnQkFDOUMsK0VBQStFO2dCQUMvRSxnRkFBZ0Y7Z0JBQ2hGLGlGQUFpRjtnQkFDakYsNEJBQTRCO2dCQUU1QjtnQkFDRSxzRkFBc0Y7Z0JBQ3RGLFdBQVcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssZUFBZTtvQkFFdEMsMkVBQTJFO29CQUMzRSxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUVsQyx3RUFBd0U7b0JBQ3hFLDZCQUE2QjtvQkFDN0IsQ0FBQyxLQUFLLENBQUMsRUFDUCxDQUFDO29CQUNELE9BQU8sQ0FBQyxDQUFDO2dCQUNYLENBQUM7WUFDSCxDQUFDO1FBQ0gsQ0FBQztJQUNILENBQUM7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2FyZXRDb25maWcgfSBmcm9tICcuL3R5cGluZ3MnO1xuXG5leHBvcnQgZnVuY3Rpb24gYWRqdXN0Q2FyZXRQb3NpdGlvbih7XG4gIHByZXZpb3VzQ29uZm9ybWVkVmFsdWUgPSAnJyxcbiAgcHJldmlvdXNQbGFjZWhvbGRlciA9ICcnLFxuICBjdXJyZW50Q2FyZXRQb3NpdGlvbiA9IDAsXG4gIGNvbmZvcm1lZFZhbHVlLFxuICByYXdWYWx1ZSxcbiAgcGxhY2Vob2xkZXJDaGFyLFxuICBwbGFjZWhvbGRlcixcbiAgaW5kZXhlc09mUGlwZWRDaGFycyA9IFtdLFxuICBjYXJldFRyYXBJbmRleGVzID0gW11cbn06IENhcmV0Q29uZmlnKTogdm9pZCB8IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gIGlmIChjdXJyZW50Q2FyZXRQb3NpdGlvbiA9PT0gMCB8fCAhcmF3VmFsdWUubGVuZ3RoKSB7IHJldHVybiAwOyB9XG5cbiAgLy8gU3RvcmUgbGVuZ3RocyBmb3IgZmFzdGVyIHBlcmZvcm1hbmNlP1xuICBjb25zdCByYXdWYWx1ZUxlbmd0aCA9IHJhd1ZhbHVlLmxlbmd0aDtcbiAgY29uc3QgcHJldmlvdXNDb25mb3JtZWRWYWx1ZUxlbmd0aCA9IHByZXZpb3VzQ29uZm9ybWVkVmFsdWUubGVuZ3RoO1xuICBjb25zdCBwbGFjZWhvbGRlckxlbmd0aCA9IHBsYWNlaG9sZGVyLmxlbmd0aDtcbiAgY29uc3QgY29uZm9ybWVkVmFsdWVMZW5ndGggPSBjb25mb3JtZWRWYWx1ZS5sZW5ndGg7XG5cbiAgLy8gVGhpcyB0ZWxscyB1cyBob3cgbG9uZyB0aGUgZWRpdCBpcy4gSWYgdXNlciBtb2RpZmllZCBpbnB1dCBmcm9tIGAoMl9fKWAgdG8gYCgyNDNfXylgLFxuICAvLyB3ZSBrbm93IHRoZSB1c2VyIGluIHRoaXMgaW5zdGFuY2UgcGFzdGVkIHR3byBjaGFyYWN0ZXJzXG4gIGNvbnN0IGVkaXRMZW5ndGggPSByYXdWYWx1ZUxlbmd0aCAtIHByZXZpb3VzQ29uZm9ybWVkVmFsdWVMZW5ndGg7XG5cbiAgLy8gSWYgdGhlIGVkaXQgbGVuZ3RoIGlzIHBvc2l0aXZlLCB0aGF0IG1lYW5zIHRoZSB1c2VyIGlzIGFkZGluZyBjaGFyYWN0ZXJzLCBub3QgZGVsZXRpbmcuXG4gIGNvbnN0IGlzQWRkaXRpb24gPSBlZGl0TGVuZ3RoID4gMDtcblxuICAvLyBUaGlzIGlzIHRoZSBmaXJzdCByYXcgdmFsdWUgdGhlIHVzZXIgZW50ZXJlZCB0aGF0IG5lZWRzIHRvIGJlIGNvbmZvcm1lZCB0byBtYXNrXG4gIGNvbnN0IGlzRmlyc3RSYXdWYWx1ZSA9IHByZXZpb3VzQ29uZm9ybWVkVmFsdWVMZW5ndGggPT09IDA7XG5cbiAgLy8gQSBwYXJ0aWFsIG11bHRpLWNoYXJhY3RlciBlZGl0IGhhcHBlbnMgd2hlbiB0aGUgdXNlciBtYWtlcyBhIHBhcnRpYWwgc2VsZWN0aW9uIGluIHRoZWlyXG4gIC8vIGlucHV0IGFuZCBlZGl0cyB0aGF0IHNlbGVjdGlvbi4gVGhhdCBpcyBnb2luZyBmcm9tIGAoMTIzKSA0MzItNDM0OGAgdG8gYCgpIDQzMi00MzQ4YCBieVxuICAvLyBzZWxlY3RpbmcgdGhlIGZpcnN0IDMgZGlnaXRzIGFuZCBwcmVzc2luZyBiYWNrc3BhY2UuXG4gIC8vXG4gIC8vIFN1Y2ggY2FzZXMgY2FuIGFsc28gaGFwcGVuIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyB0aGUgYmFja3NwYWNlIHdoaWxlIGhvbGRpbmcgZG93biB0aGUgQUxUXG4gIC8vIGtleS5cbiAgY29uc3QgaXNQYXJ0aWFsTXVsdGlDaGFyRWRpdCA9IGVkaXRMZW5ndGggPiAxICYmICFpc0FkZGl0aW9uICYmICFpc0ZpcnN0UmF3VmFsdWU7XG5cbiAgLy8gVGhpcyBhbGdvcml0aG0gZG9lc24ndCBzdXBwb3J0IGFsbCBjYXNlcyBvZiBtdWx0aS1jaGFyYWN0ZXIgZWRpdHMsIHNvIHdlIGp1c3QgcmV0dXJuXG4gIC8vIHRoZSBjdXJyZW50IGNhcmV0IHBvc2l0aW9uLlxuICAvL1xuICAvLyBUaGlzIHdvcmtzIGZpbmUgZm9yIG1vc3QgY2FzZXMuXG4gIGlmIChpc1BhcnRpYWxNdWx0aUNoYXJFZGl0KSB7IHJldHVybiBjdXJyZW50Q2FyZXRQb3NpdGlvbjsgfVxuXG4gIC8vIEZvciBhIG1hc2sgbGlrZSAoMTExKSwgaWYgdGhlIGBwcmV2aW91c0NvbmZvcm1lZFZhbHVlYCBpcyAoMV9fKSBhbmQgdXNlciBhdHRlbXB0cyB0byBlbnRlclxuICAvLyBgZmAgc28gdGhlIGByYXdWYWx1ZWAgYmVjb21lcyAoMWZfXyksIHRoZSBuZXcgYGNvbmZvcm1lZFZhbHVlYCB3b3VsZCBiZSAoMV9fKSwgd2hpY2ggaXMgdGhlXG4gIC8vIHNhbWUgYXMgdGhlIG9yaWdpbmFsIGBwcmV2aW91c0NvbmZvcm1lZFZhbHVlYC4gV2UgaGFuZGxlIHRoaXMgY2FzZSBkaWZmZXJlbnRseSBmb3IgY2FyZXRcbiAgLy8gcG9zaXRpb25pbmcuXG4gIGNvbnN0IHBvc3NpYmx5SGFzUmVqZWN0ZWRDaGFyID0gaXNBZGRpdGlvbiAmJiAoXG4gICAgcHJldmlvdXNDb25mb3JtZWRWYWx1ZSA9PT0gY29uZm9ybWVkVmFsdWUgfHxcbiAgICBjb25mb3JtZWRWYWx1ZSA9PT0gcGxhY2Vob2xkZXJcbiAgKTtcblxuICBsZXQgc3RhcnRpbmdTZWFyY2hJbmRleCA9IDA7XG4gIGxldCB0cmFja1JpZ2h0Q2hhcmFjdGVyO1xuICBsZXQgdGFyZ2V0Q2hhciA9ICcnO1xuXG4gIGlmIChwb3NzaWJseUhhc1JlamVjdGVkQ2hhcikge1xuICAgIHN0YXJ0aW5nU2VhcmNoSW5kZXggPSBjdXJyZW50Q2FyZXRQb3NpdGlvbiAtIGVkaXRMZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXQgdGhpcyBwb2ludCBpbiB0aGUgYWxnb3JpdGhtLCB3ZSB3YW50IHRvIGtub3cgd2hlcmUgdGhlIGNhcmV0IGlzIHJpZ2h0IGJlZm9yZSB0aGUgcmF3IGlucHV0XG4gICAgLy8gaGFzIGJlZW4gY29uZm9ybWVkLCBhbmQgdGhlbiBzZWUgaWYgd2UgY2FuIGZpbmQgdGhhdCBzYW1lIHNwb3QgaW4gdGhlIGNvbmZvcm1lZCBpbnB1dC5cbiAgICAvL1xuICAgIC8vIFdlIGRvIHRoYXQgYnkgc2VlaW5nIHdoYXQgY2hhcmFjdGVyIGxpZXMgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBjYXJldCwgYW5kIHRoZW4gbG9vayBmb3IgdGhhdFxuICAgIC8vIHNhbWUgY2hhcmFjdGVyIGluIHRoZSBjb25mb3JtZWQgaW5wdXQgYW5kIHBsYWNlIHRoZSBjYXJldCB0aGVyZS5cblxuICAgIC8vIEZpcnN0LCB3ZSBuZWVkIHRvIG5vcm1hbGl6ZSB0aGUgaW5wdXRzIHNvIHRoYXQgbGV0dGVyIGNhcGl0YWxpemF0aW9uIGJldHdlZW4gcmF3IGlucHV0IGFuZFxuICAgIC8vIGNvbmZvcm1lZCBpbnB1dCB3b3VsZG4ndCBtYXR0ZXIuXG4gICAgY29uc3Qgbm9ybWFsaXplZENvbmZvcm1lZFZhbHVlID0gY29uZm9ybWVkVmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBub3JtYWxpemVkUmF3VmFsdWUgPSByYXdWYWx1ZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gVGhlbiB3ZSB0YWtlIGFsbCBjaGFyYWN0ZXJzIHRoYXQgY29tZSBiZWZvcmUgd2hlcmUgdGhlIGNhcmV0IGN1cnJlbnRseSBpcy5cbiAgICBjb25zdCBsZWZ0SGFsZkNoYXJzID0gbm9ybWFsaXplZFJhd1ZhbHVlLnN1YnN0cigwLCBjdXJyZW50Q2FyZXRQb3NpdGlvbikuc3BsaXQoJycpO1xuXG4gICAgLy8gTm93IHdlIGZpbmQgYWxsIHRoZSBjaGFyYWN0ZXJzIGluIHRoZSBsZWZ0IGhhbGYgdGhhdCBleGlzdCBpbiB0aGUgY29uZm9ybWVkIGlucHV0XG4gICAgLy8gVGhpcyBzdGVwIGVuc3VyZXMgdGhhdCB3ZSBkb24ndCBsb29rIGZvciBhIGNoYXJhY3RlciB0aGF0IHdhcyBmaWx0ZXJlZCBvdXQgb3IgcmVqZWN0ZWQgYnkgYGNvbmZvcm1Ub01hc2tgLlxuICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IGxlZnRIYWxmQ2hhcnMuZmlsdGVyKChjaGFyKSA9PiBub3JtYWxpemVkQ29uZm9ybWVkVmFsdWUuaW5kZXhPZihjaGFyKSAhPT0gLTEpO1xuXG4gICAgLy8gVGhlIGxhc3QgY2hhcmFjdGVyIGluIHRoZSBpbnRlcnNlY3Rpb24gaXMgdGhlIGNoYXJhY3RlciB3ZSB3YW50IHRvIGxvb2sgZm9yIGluIHRoZSBjb25mb3JtZWRcbiAgICAvLyB2YWx1ZSBhbmQgdGhlIG9uZSB3ZSB3YW50IHRvIGFkanVzdCB0aGUgY2FyZXQgY2xvc2UgdG9cbiAgICB0YXJnZXRDaGFyID0gaW50ZXJzZWN0aW9uW2ludGVyc2VjdGlvbi5sZW5ndGggLSAxXTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIG1hc2sgY2hhcmFjdGVycyBpbiB0aGUgcHJldmlvdXMgcGxhY2Vob2xkZXJcbiAgICAvLyBmcm9tIHRoZSBzdGFydCBvZiB0aGUgc3RyaW5nIHVwIHRvIHRoZSBwbGFjZSB3aGVyZSB0aGUgY2FyZXQgaXNcbiAgICBjb25zdCBwcmV2aW91c0xlZnRNYXNrQ2hhcnMgPSBwcmV2aW91c1BsYWNlaG9sZGVyXG4gICAgICAuc3Vic3RyKDAsIGludGVyc2VjdGlvbi5sZW5ndGgpXG4gICAgICAuc3BsaXQoJycpXG4gICAgICAuZmlsdGVyKGNoYXIgPT4gY2hhciAhPT0gcGxhY2Vob2xkZXJDaGFyKVxuICAgICAgLmxlbmd0aDtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIG1hc2sgY2hhcmFjdGVycyBpbiB0aGUgY3VycmVudCBwbGFjZWhvbGRlclxuICAgIC8vIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBzdHJpbmcgdXAgdG8gdGhlIHBsYWNlIHdoZXJlIHRoZSBjYXJldCBpc1xuICAgIGNvbnN0IGxlZnRNYXNrQ2hhcnMgPSBwbGFjZWhvbGRlclxuICAgICAgLnN1YnN0cigwLCBpbnRlcnNlY3Rpb24ubGVuZ3RoKVxuICAgICAgLnNwbGl0KCcnKVxuICAgICAgLmZpbHRlcihjaGFyID0+IGNoYXIgIT09IHBsYWNlaG9sZGVyQ2hhcilcbiAgICAgIC5sZW5ndGg7XG5cbiAgICAvLyBIYXMgdGhlIG51bWJlciBvZiBtYXNrIGNoYXJhY3RlcnMgdXAgdG8gdGhlIGNhcmV0IGNoYW5nZWQ/XG4gICAgY29uc3QgbWFza2xlbmd0aENoYW5nZWQgPSBsZWZ0TWFza0NoYXJzICE9PSBwcmV2aW91c0xlZnRNYXNrQ2hhcnM7XG5cbiAgICAvLyBEZXRlY3QgaWYgYHRhcmdldENoYXJgIGlzIGEgbWFzayBjaGFyYWN0ZXIgYW5kIGhhcyBtb3ZlZCB0byB0aGUgbGVmdFxuICAgIGNvbnN0IHRhcmdldElzTWFza01vdmluZ0xlZnQgPSAoXG4gICAgICBwcmV2aW91c1BsYWNlaG9sZGVyW2ludGVyc2VjdGlvbi5sZW5ndGggLSAxXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBwbGFjZWhvbGRlcltpbnRlcnNlY3Rpb24ubGVuZ3RoIC0gMl0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgcHJldmlvdXNQbGFjZWhvbGRlcltpbnRlcnNlY3Rpb24ubGVuZ3RoIC0gMV0gIT09IHBsYWNlaG9sZGVyQ2hhciAmJlxuICAgICAgcHJldmlvdXNQbGFjZWhvbGRlcltpbnRlcnNlY3Rpb24ubGVuZ3RoIC0gMV0gIT09IHBsYWNlaG9sZGVyW2ludGVyc2VjdGlvbi5sZW5ndGggLSAxXSAmJlxuICAgICAgcHJldmlvdXNQbGFjZWhvbGRlcltpbnRlcnNlY3Rpb24ubGVuZ3RoIC0gMV0gPT09IHBsYWNlaG9sZGVyW2ludGVyc2VjdGlvbi5sZW5ndGggLSAyXVxuICAgICk7XG5cbiAgICAvLyBJZiBkZWxldGluZyBhbmQgdGhlIGB0YXJnZXRDaGFyYCBgaXMgYSBtYXNrIGNoYXJhY3RlciBhbmQgYG1hc2tsZW5ndGhDaGFuZ2VkYCBpcyB0cnVlXG4gICAgLy8gb3IgdGhlIG1hc2sgaXMgbW92aW5nIHRvIHRoZSBsZWZ0LCB3ZSBjYW4ndCB1c2UgdGhlIHNlbGVjdGVkIGB0YXJnZXRDaGFyYCBhbnkgbG9uZ2VyXG4gICAgLy8gaWYgd2UgYXJlIG5vdCBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcuXG4gICAgLy8gSW4gdGhpcyBjYXNlLCBjaGFuZ2UgdHJhY2tpbmcgc3RyYXRlZ3kgYW5kIHRyYWNrIHRoZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjYXJldC5cbiAgICBpZiAoXG4gICAgICAhaXNBZGRpdGlvbiAmJlxuICAgICAgKG1hc2tsZW5ndGhDaGFuZ2VkIHx8IHRhcmdldElzTWFza01vdmluZ0xlZnQpICYmXG4gICAgICBwcmV2aW91c0xlZnRNYXNrQ2hhcnMgPiAwICYmXG4gICAgICBwbGFjZWhvbGRlci5pbmRleE9mKHRhcmdldENoYXIpID4gLTEgJiZcbiAgICAgIHJhd1ZhbHVlW2N1cnJlbnRDYXJldFBvc2l0aW9uXSAhPT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICB0cmFja1JpZ2h0Q2hhcmFjdGVyID0gdHJ1ZTtcbiAgICAgIHRhcmdldENoYXIgPSByYXdWYWx1ZVtjdXJyZW50Q2FyZXRQb3NpdGlvbl07XG4gICAgfVxuXG4gICAgLy8gSXQgaXMgcG9zc2libGUgdGhhdCBgdGFyZ2V0Q2hhcmAgd2lsbCBhcHBlYXIgbXVsdGlwbGUgdGltZXMgaW4gdGhlIGNvbmZvcm1lZCB2YWx1ZS5cbiAgICAvLyBXZSBuZWVkIHRvIGtub3cgbm90IHRvIHNlbGVjdCBhIGNoYXJhY3RlciB0aGF0IGxvb2tzIGxpa2Ugb3VyIHRhcmdldCBjaGFyYWN0ZXIgZnJvbSB0aGUgcGxhY2Vob2xkZXIgb3JcbiAgICAvLyB0aGUgcGlwZWQgY2hhcmFjdGVycywgc28gd2UgaW5zcGVjdCB0aGUgcGlwZWQgY2hhcmFjdGVycyBhbmQgdGhlIHBsYWNlaG9sZGVyIHRvIHNlZSBpZiB0aGV5IGNvbnRhaW5cbiAgICAvLyBjaGFyYWN0ZXJzIHRoYXQgbWF0Y2ggb3VyIHRhcmdldCBjaGFyYWN0ZXIuXG5cbiAgICAvLyBJZiB0aGUgYGNvbmZvcm1lZFZhbHVlYCBnb3QgcGlwZWQsIHdlIG5lZWQgdG8ga25vdyB3aGljaCBjaGFyYWN0ZXJzIHdlcmUgcGlwZWQgaW4gc28gdGhhdCB3aGVuIHdlIGxvb2sgZm9yXG4gICAgLy8gb3VyIGB0YXJnZXRDaGFyYCwgd2UgZG9uJ3Qgc2VsZWN0IGEgcGlwZWQgY2hhciBieSBtaXN0YWtlXG4gICAgY29uc3QgcGlwZWRDaGFycyA9IGluZGV4ZXNPZlBpcGVkQ2hhcnMubWFwKChpbmRleCkgPT4gbm9ybWFsaXplZENvbmZvcm1lZFZhbHVlW2luZGV4XSk7XG5cbiAgICAvLyBXZSBuZWVkIHRvIGtub3cgaG93IG1hbnkgdGltZXMgdGhlIGB0YXJnZXRDaGFyYCBvY2N1cnMgaW4gdGhlIHBpcGVkIGNoYXJhY3RlcnMuXG4gICAgY29uc3QgY291bnRUYXJnZXRDaGFySW5QaXBlZENoYXJzID0gcGlwZWRDaGFycy5maWx0ZXIoKGNoYXIpID0+IGNoYXIgPT09IHRhcmdldENoYXIpLmxlbmd0aDtcblxuICAgIC8vIFdlIG5lZWQgdG8ga25vdyBob3cgbWFueSB0aW1lcyBpdCBvY2N1cnMgaW4gdGhlIGludGVyc2VjdGlvblxuICAgIGNvbnN0IGNvdW50VGFyZ2V0Q2hhckluSW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uLmZpbHRlcigoY2hhcikgPT4gY2hhciA9PT0gdGFyZ2V0Q2hhcikubGVuZ3RoO1xuXG4gICAgLy8gV2UgbmVlZCB0byBrbm93IGlmIHRoZSBwbGFjZWhvbGRlciBjb250YWlucyBjaGFyYWN0ZXJzIHRoYXQgbG9vayBsaWtlXG4gICAgLy8gb3VyIGB0YXJnZXRDaGFyYCwgc28gd2UgZG9uJ3Qgc2VsZWN0IG9uZSBvZiB0aG9zZSBieSBtaXN0YWtlLlxuICAgIGNvbnN0IGNvdW50VGFyZ2V0Q2hhckluUGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlclxuICAgICAgLnN1YnN0cigwLCBwbGFjZWhvbGRlci5pbmRleE9mKHBsYWNlaG9sZGVyQ2hhcikpXG4gICAgICAuc3BsaXQoJycpXG4gICAgICAuZmlsdGVyKChjaGFyLCBpbmRleCkgPT4gKFxuICAgICAgICAvLyBDaGVjayBpZiBgY2hhcmAgaXMgdGhlIHNhbWUgYXMgb3VyIGB0YXJnZXRDaGFyYCwgc28gd2UgYWNjb3VudCBmb3IgaXRcbiAgICAgICAgY2hhciA9PT0gdGFyZ2V0Q2hhciAmJlxuXG4gICAgICAgIC8vIGJ1dCBhbHNvIG1ha2Ugc3VyZSB0aGF0IGJvdGggdGhlIGByYXdWYWx1ZWAgYW5kIHBsYWNlaG9sZGVyIGRvbid0IGhhdmUgdGhlIHNhbWUgY2hhcmFjdGVyIGF0IHRoZSBzYW1lXG4gICAgICAgIC8vIGluZGV4IGJlY2F1c2UgaWYgdGhleSBhcmUgZXF1YWwsIHRoYXQgbWVhbnMgd2UgYXJlIGFscmVhZHkgY291bnRpbmcgdGhvc2UgY2hhcmFjdGVycyBpblxuICAgICAgICAvLyBgY291bnRUYXJnZXRDaGFySW5JbnRlcnNlY3Rpb25gXG4gICAgICAgIHJhd1ZhbHVlW2luZGV4XSAhPT0gY2hhclxuICAgICAgKSlcbiAgICAgIC5sZW5ndGg7XG5cbiAgICAvLyBUaGUgbnVtYmVyIG9mIHRpbWVzIHdlIG5lZWQgdG8gc2VlIG9jY3VycmVuY2VzIG9mIHRoZSBgdGFyZ2V0Q2hhcmAgYmVmb3JlIHdlIGtub3cgaXQgaXMgdGhlIG9uZSB3ZSdyZSBsb29raW5nXG4gICAgLy8gZm9yIGlzOlxuICAgIGNvbnN0IHJlcXVpcmVkTnVtYmVyT2ZNYXRjaGVzID0gKFxuICAgICAgY291bnRUYXJnZXRDaGFySW5QbGFjZWhvbGRlciArXG4gICAgICBjb3VudFRhcmdldENoYXJJbkludGVyc2VjdGlvbiArXG4gICAgICBjb3VudFRhcmdldENoYXJJblBpcGVkQ2hhcnMgK1xuICAgICAgLy8gVGhlIGNoYXJhY3RlciB0byB0aGUgcmlnaHQgb2YgdGhlIGNhcmV0IGlzbid0IGluY2x1ZGVkIGluIGBpbnRlcnNlY3Rpb25gXG4gICAgICAvLyBzbyBhZGQgb25lIGlmIHdlIGFyZSB0cmFja2luZyB0aGUgY2hhcmFjdGVyIHRvIHRoZSByaWdodFxuICAgICAgKHRyYWNrUmlnaHRDaGFyYWN0ZXIgPyAxIDogMClcbiAgICApO1xuXG4gICAgLy8gTm93IHdlIHN0YXJ0IGxvb2tpbmcgZm9yIHRoZSBsb2NhdGlvbiBvZiB0aGUgYHRhcmdldENoYXJgLlxuICAgIC8vIFdlIGtlZXAgbG9vcGluZyBmb3J3YXJkIGFuZCBzdG9yZSB0aGUgaW5kZXggaW4gZXZlcnkgaXRlcmF0aW9uLiBPbmNlIHdlIGhhdmUgZW5jb3VudGVyZWRcbiAgICAvLyBlbm91Z2ggb2NjdXJyZW5jZXMgb2YgdGhlIHRhcmdldCBjaGFyYWN0ZXIsIHdlIGJyZWFrIG91dCBvZiB0aGUgbG9vcFxuICAgIC8vIElmIGFyZSBzZWFyY2hpbmcgZm9yIHRoZSBzZWNvbmQgYDFgIGluIGAxMjE0YCwgYHN0YXJ0aW5nU2VhcmNoSW5kZXhgIHdpbGwgcG9pbnQgYXQgYDRgLlxuICAgIGxldCBudW1iZXJPZkVuY291bnRlcmVkTWF0Y2hlcyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25mb3JtZWRWYWx1ZUxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjb25mb3JtZWRWYWx1ZUNoYXIgPSBub3JtYWxpemVkQ29uZm9ybWVkVmFsdWVbaV07XG5cbiAgICAgIHN0YXJ0aW5nU2VhcmNoSW5kZXggPSBpICsgMTtcblxuICAgICAgaWYgKGNvbmZvcm1lZFZhbHVlQ2hhciA9PT0gdGFyZ2V0Q2hhcikge1xuICAgICAgICBudW1iZXJPZkVuY291bnRlcmVkTWF0Y2hlcysrO1xuICAgICAgfVxuXG4gICAgICBpZiAobnVtYmVyT2ZFbmNvdW50ZXJlZE1hdGNoZXMgPj0gcmVxdWlyZWROdW1iZXJPZk1hdGNoZXMpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCwgaWYgd2Ugc2ltcGx5IHJldHVybiBgc3RhcnRpbmdTZWFyY2hJbmRleGAgYXMgdGhlIGFkanVzdGVkIGNhcmV0IHBvc2l0aW9uLFxuICAvLyBtb3N0IGNhc2VzIHdvdWxkIGJlIGhhbmRsZWQuIEhvd2V2ZXIsIHdlIHdhbnQgdG8gZmFzdCBmb3J3YXJkIG9yIHJld2luZCB0aGUgY2FyZXQgdG8gdGhlXG4gIC8vIGNsb3Nlc3QgcGxhY2Vob2xkZXIgY2hhcmFjdGVyIGlmIGl0IGhhcHBlbnMgdG8gYmUgaW4gYSBub24tZWRpdGFibGUgc3BvdC4gVGhhdCdzIHdoYXQgdGhlIG5leHRcbiAgLy8gbG9naWMgaXMgZm9yLlxuXG4gIC8vIEluIGNhc2Ugb2YgYWRkaXRpb24sIHdlIGZhc3QgZm9yd2FyZC5cbiAgaWYgKGlzQWRkaXRpb24pIHtcbiAgICAvLyBXZSB3YW50IHRvIHJlbWVtYmVyIHRoZSBsYXN0IHBsYWNlaG9sZGVyIGNoYXJhY3RlciBlbmNvdW50ZXJlZCBzbyB0aGF0IGlmIHRoZSBtYXNrXG4gICAgLy8gY29udGFpbnMgbW9yZSBjaGFyYWN0ZXJzIGFmdGVyIHRoZSBsYXN0IHBsYWNlaG9sZGVyIGNoYXJhY3Rlciwgd2UgZG9uJ3QgZm9yd2FyZCB0aGUgY2FyZXRcbiAgICAvLyB0aGF0IGZhciB0byB0aGUgcmlnaHQuIEluc3RlYWQsIHdlIHN0b3AgaXQgYXQgdGhlIGxhc3QgZW5jb3VudGVyZWQgcGxhY2Vob2xkZXIgY2hhcmFjdGVyLlxuICAgIGxldCBsYXN0UGxhY2Vob2xkZXJDaGFyID0gc3RhcnRpbmdTZWFyY2hJbmRleDtcblxuICAgIGZvciAobGV0IGkgPSBzdGFydGluZ1NlYXJjaEluZGV4OyBpIDw9IHBsYWNlaG9sZGVyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwbGFjZWhvbGRlcltpXSA9PT0gcGxhY2Vob2xkZXJDaGFyKSB7XG4gICAgICAgIGxhc3RQbGFjZWhvbGRlckNoYXIgPSBpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIC8vIElmIHdlJ3JlIGFkZGluZywgd2UgY2FuIHBvc2l0aW9uIHRoZSBjYXJldCBhdCB0aGUgbmV4dCBwbGFjZWhvbGRlciBjaGFyYWN0ZXIuXG4gICAgICAgIHBsYWNlaG9sZGVyW2ldID09PSBwbGFjZWhvbGRlckNoYXIgfHxcblxuICAgICAgICAvLyBJZiBhIGNhcmV0IHRyYXAgd2FzIHNldCBieSBhIG1hc2sgZnVuY3Rpb24sIHdlIG5lZWQgdG8gc3RvcCBhdCB0aGUgdHJhcC5cbiAgICAgICAgY2FyZXRUcmFwSW5kZXhlcy5pbmRleE9mKGkpICE9PSAtMSB8fFxuXG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGVuZCBvZiB0aGUgcGxhY2Vob2xkZXIuIFdlIGNhbm5vdCBtb3ZlIGFueSBmdXJ0aGVyLiBMZXQncyBwdXQgdGhlIGNhcmV0IHRoZXJlLlxuICAgICAgICBpID09PSBwbGFjZWhvbGRlckxlbmd0aFxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBsYXN0UGxhY2Vob2xkZXJDaGFyO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJbiBjYXNlIG9mIGRlbGV0aW9uLCB3ZSByZXdpbmQuXG4gICAgaWYgKHRyYWNrUmlnaHRDaGFyYWN0ZXIpIHtcbiAgICAgIC8vIFNlYXJjaGluZyBmb3IgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyB0byB0aGUgcmlnaHQgb2YgdGhlIGNhcmV0XG4gICAgICAvLyBXZSBzdGFydCBhdCBgc3RhcnRpbmdTZWFyY2hJbmRleGAgLSAxIGJlY2F1c2UgaXQgaW5jbHVkZXMgb25lIGNoYXJhY3RlciBleHRyYSB0byB0aGUgcmlnaHRcbiAgICAgIGZvciAobGV0IGkgPSBzdGFydGluZ1NlYXJjaEluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgLy8gSWYgdHJhY2tpbmcgdGhlIGNoYXJhY3RlciB0byB0aGUgcmlnaHQgb2YgdGhlIGN1cnNvciwgd2UgbW92ZSB0byB0aGUgbGVmdCB1bnRpbFxuICAgICAgICAvLyB3ZSBmb3VuZCB0aGUgY2hhcmFjdGVyIGFuZCB0aGVuIHBsYWNlIHRoZSBjYXJldCByaWdodCBiZWZvcmUgaXRcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgLy8gYHRhcmdldENoYXJgIHNob3VsZCBiZSBpbiBgY29uZm9ybWVkVmFsdWVgLCBzaW5jZSBpdCB3YXMgaW4gYHJhd1ZhbHVlYCwganVzdFxuICAgICAgICAgIC8vIHRvIHRoZSByaWdodCBvZiB0aGUgY2FyZXRcbiAgICAgICAgICBjb25mb3JtZWRWYWx1ZVtpXSA9PT0gdGFyZ2V0Q2hhciB8fFxuXG4gICAgICAgICAgLy8gSWYgYSBjYXJldCB0cmFwIHdhcyBzZXQgYnkgYSBtYXNrIGZ1bmN0aW9uLCB3ZSBuZWVkIHRvIHN0b3AgYXQgdGhlIHRyYXAuXG4gICAgICAgICAgY2FyZXRUcmFwSW5kZXhlcy5pbmRleE9mKGkpICE9PSAtMSB8fFxuXG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBwbGFjZWhvbGRlci4gV2UgY2Fubm90IG1vdmUgYW55IGZ1cnRoZXIuXG4gICAgICAgICAgLy8gTGV0J3MgcHV0IHRoZSBjYXJldCB0aGVyZS5cbiAgICAgICAgICBpID09PSAwXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlYXJjaGluZyBmb3IgdGhlIGZpcnN0IHBsYWNlaG9sZGVyIG9yIGNhcmV0IHRyYXAgdG8gdGhlIGxlZnRcblxuICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0aW5nU2VhcmNoSW5kZXg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIC8vIElmIHdlJ3JlIGRlbGV0aW5nLCB3ZSBzdG9wIHRoZSBjYXJldCByaWdodCBiZWZvcmUgdGhlIHBsYWNlaG9sZGVyIGNoYXJhY3Rlci5cbiAgICAgICAgLy8gRm9yIGV4YW1wbGUsIGZvciBtYXNrIGAoMTExKSAxMWAsIGN1cnJlbnQgY29uZm9ybWVkIGlucHV0IGAoNDU2KSA4NmAuIElmIHVzZXJcbiAgICAgICAgLy8gbW9kaWZpZXMgaW5wdXQgdG8gYCg0NTYgODZgLiBUaGF0IGlzLCB0aGV5IGRlbGV0ZWQgdGhlIGApYCwgd2UgcGxhY2UgdGhlIGNhcmV0XG4gICAgICAgIC8vIHJpZ2h0IGFmdGVyIHRoZSBmaXJzdCBgNmBcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgLy8gSWYgd2UncmUgZGVsZXRpbmcsIHdlIGNhbiBwb3NpdGlvbiB0aGUgY2FyZXQgcmlnaHQgYmVmb3JlIHRoZSBwbGFjZWhvbGRlciBjaGFyYWN0ZXJcbiAgICAgICAgICBwbGFjZWhvbGRlcltpIC0gMV0gPT09IHBsYWNlaG9sZGVyQ2hhciB8fFxuXG4gICAgICAgICAgLy8gSWYgYSBjYXJldCB0cmFwIHdhcyBzZXQgYnkgYSBtYXNrIGZ1bmN0aW9uLCB3ZSBuZWVkIHRvIHN0b3AgYXQgdGhlIHRyYXAuXG4gICAgICAgICAgY2FyZXRUcmFwSW5kZXhlcy5pbmRleE9mKGkpICE9PSAtMSB8fFxuXG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBwbGFjZWhvbGRlci4gV2UgY2Fubm90IG1vdmUgYW55IGZ1cnRoZXIuXG4gICAgICAgICAgLy8gTGV0J3MgcHV0IHRoZSBjYXJldCB0aGVyZS5cbiAgICAgICAgICBpID09PSAwXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXX0=