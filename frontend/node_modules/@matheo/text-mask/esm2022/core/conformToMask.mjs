import { convertMaskToPlaceholder, isArray, isMaskCreator, processCaretTraps } from './utilities';
import { defaultPlaceholderChar } from './constants';
export const err = 'Text-mask:conformToMask; The mask property must be an array.';
export function conformToMask(rawValue = '', mask = [], config = {}) {
    if (!isArray(mask)) {
        // If someone passes a function as the mask property, we should call the
        // function to get the mask array - Normally this is handled by the
        // `createTextMaskInputElement:update` function - this allows mask functions
        // to be used directly with `conformToMask`
        if (isMaskCreator(mask)) {
            // call the mask function to get the mask array
            mask = mask(rawValue, config);
            // mask functions can setup caret traps to have some control over how the caret moves. We need to process
            // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask
            processCaretTraps(mask);
        }
        else {
            throw new Error(err);
        }
    }
    // These configurations tell us how to conform the mask
    const { guide = true, previousConformedValue = '', placeholderChar = defaultPlaceholderChar, placeholder = convertMaskToPlaceholder(mask, placeholderChar), currentCaretPosition, keepCharPositions } = config;
    // The configs below indicate that the user wants the algorithm to work in *no guide* mode
    const suppressGuide = guide === false && previousConformedValue !== undefined;
    // Calculate lengths once for performance
    const rawValueLength = rawValue.length;
    const previousConformedValueLength = previousConformedValue.length;
    const placeholderLength = placeholder.length;
    const maskLength = mask.length;
    // This tells us the number of edited characters and the direction in which they were edited (+/-)
    const editDistance = rawValueLength - previousConformedValueLength;
    // In *no guide* mode, we need to know if the user is trying to add a character or not
    const isAddition = editDistance > 0;
    // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1
    const indexOfFirstChange = (currentCaretPosition || 0) + (isAddition ? -editDistance : 0);
    // We're also gonna need the index of last change, which we can derive as follows...
    const indexOfLastChange = indexOfFirstChange + Math.abs(editDistance);
    // If `conformToMask` is configured to keep character positions, that is, for mask 111, previous value
    // _2_ and raw value 3_2_, the new conformed value should be 32_, not 3_2 (default behavior). That's in the case of
    // addition. And in the case of deletion, previous value _23, raw value _3, the new conformed string should be
    // __3, not _3_ (default behavior)
    //
    // The next block of logic handles keeping character positions for the case of deletion. (Keeping
    // character positions for the case of addition is further down since it is handled differently.)
    // To do this, we want to compensate for all characters that were deleted
    if (keepCharPositions === true && !isAddition) {
        // We will be storing the new placeholder characters in this variable.
        let compensatingPlaceholderChars = '';
        // For every character that was deleted from a placeholder position, we add a placeholder char
        for (let i = indexOfFirstChange; i < indexOfLastChange; i++) {
            if (placeholder[i] === placeholderChar) {
                compensatingPlaceholderChars += placeholderChar;
            }
        }
        // Now we trick our algorithm by modifying the raw value to make it contain additional placeholder characters
        // That way when the we start laying the characters again on the mask, it will keep the non-deleted characters
        // in their positions.
        rawValue = (rawValue.slice(0, indexOfFirstChange) +
            compensatingPlaceholderChars +
            rawValue.slice(indexOfFirstChange, rawValueLength));
    }
    // Convert `rawValue` string to an array, and mark characters based on whether they are newly added or have
    // existed in the previous conformed value. Identifying new and old characters is needed for `conformToMask`
    // to work if it is configured to keep character positions.
    const rawValueArr = rawValue
        .split('')
        .map((char, i) => ({ char, isNew: i >= indexOfFirstChange && i < indexOfLastChange }));
    // The loop below removes masking characters from user input. For example, for mask
    // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below
    // would remove all characters but `234` from the `rawValueArr`. The rest of the algorithm
    // then would lay `234` on top of the available placeholder positions in the mask.
    for (let i = rawValueLength - 1; i >= 0; i--) {
        const { char } = rawValueArr[i];
        if (char !== placeholderChar) {
            const shouldOffset = i >= indexOfFirstChange && previousConformedValueLength === maskLength;
            if (char === placeholder[(shouldOffset) ? i - editDistance : i]) {
                rawValueArr.splice(i, 1);
            }
        }
    }
    // This is the variable that we will be filling with characters as we figure them out
    // in the algorithm below
    let conformedValue = '';
    let someCharsRejected = false;
    // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.
    placeholderLoop: for (let i = 0; i < placeholderLength; i++) {
        const charInPlaceholder = placeholder[i];
        // We see one. Let's find out what we can put in it.
        if (charInPlaceholder === placeholderChar) {
            // But before that, do we actually have any user characters that need a place?
            if (rawValueArr.length > 0) {
                // We will keep chipping away at user input until either we run out of characters
                // or we find at least one character that we can map.
                while (rawValueArr.length > 0) {
                    // Let's retrieve the first user character in the queue of characters we have left
                    const res = rawValueArr.shift();
                    // If the character we got from the user input is a placeholder character (which happens
                    // regularly because user input could be something like (540) 90_-____, which includes
                    // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,
                    // then we map this placeholder character to the current spot in the placeholder
                    if (res?.char === placeholderChar && suppressGuide !== true) {
                        conformedValue += placeholderChar;
                        // And we go to find the next placeholder character that needs filling
                        continue placeholderLoop;
                        // Else if, the character we got from the user input is not a placeholder, let's see
                        // if the current position in the mask can accept it.
                    }
                    else if (res?.char && mask[i].test(res.char)) {
                        // we map the character differently based on whether we are keeping character positions or not.
                        // If any of the conditions below are met, we simply map the raw value character to the
                        // placeholder position.
                        if (keepCharPositions !== true ||
                            res?.isNew === false ||
                            previousConformedValue === '' ||
                            guide === false ||
                            !isAddition) {
                            conformedValue += res?.char;
                        }
                        else {
                            // We enter this block of code if we are trying to keep character positions and none of the conditions
                            // above is met. In this case, we need to see if there's an available spot for the raw value character
                            // to be mapped to. If we couldn't find a spot, we will discard the character.
                            //
                            // For example, for mask `1111`, previous conformed value `_2__`, raw value `942_2__`. We can map the
                            // `9`, to the first available placeholder position, but then, there are no more spots available for the
                            // `4` and `2`. So, we discard them and end up with a conformed value of `92__`.
                            const rawValueArrLength = rawValueArr.length;
                            let indexOfNextAvailablePlaceholderChar = null;
                            // Let's loop through the remaining raw value characters. We are looking for either a suitable spot, ie,
                            // a placeholder character or a non-suitable spot, ie, a non-placeholder character that is not new.
                            // If we see a suitable spot first, we store its position and exit the loop. If we see a non-suitable
                            // spot first, we exit the loop and our `indexOfNextAvailablePlaceholderChar` will stay as `null`.
                            for (let k = 0; k < rawValueArrLength; k++) {
                                const charData = rawValueArr[k];
                                if (charData.char !== placeholderChar && charData.isNew === false) {
                                    break;
                                }
                                if (charData.char === placeholderChar) {
                                    indexOfNextAvailablePlaceholderChar = k;
                                    break;
                                }
                            }
                            // If `indexOfNextAvailablePlaceholderChar` is not `null`, that means the character is not blocked.
                            // We can map it. And to keep the character positions, we remove the placeholder character
                            // from the remaining characters
                            if (indexOfNextAvailablePlaceholderChar !== null) {
                                conformedValue += res?.char;
                                rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1);
                                // If `indexOfNextAvailablePlaceholderChar` is `null`, that means the character is blocked. We have to
                                // discard it.
                            }
                            else {
                                i--;
                            }
                        }
                        // Since we've mapped this placeholder position. We move on to the next one.
                        continue placeholderLoop;
                    }
                    else {
                        someCharsRejected = true;
                    }
                }
            }
            // We reach this point when we've mapped all the user input characters to placeholder
            // positions in the mask. In *guide* mode, we append the left over characters in the
            // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.
            //
            // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.
            if (suppressGuide === false) {
                conformedValue += placeholder.substr(i, placeholderLength);
            }
            // And we break
            break;
            // Else, the charInPlaceholder is not a placeholderChar. That is, we cannot fill it
            // with user input. So we just map it to the final output
        }
        else {
            conformedValue += charInPlaceholder;
        }
    }
    // The following logic is needed to deal with the case of deletion in *no guide* mode.
    //
    // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder
    // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.
    // That's why the logic below finds the last filled placeholder character, and removes everything
    // from that point on.
    if (suppressGuide && isAddition === false) {
        let indexOfLastFilledPlaceholderChar = null;
        // Find the last filled placeholder position and substring from there
        for (let i = 0; i < conformedValue.length; i++) {
            if (placeholder[i] === placeholderChar) {
                indexOfLastFilledPlaceholderChar = i;
            }
        }
        if (indexOfLastFilledPlaceholderChar !== null) {
            // We substring from the beginning until the position after the last filled placeholder char.
            conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1);
        }
        else {
            // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted
            // the first character in the mask. So we return an empty string.
            conformedValue = '';
        }
    }
    return { conformedValue, meta: { someCharsRejected } };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uZm9ybVRvTWFzay5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvY29yZS9jb25mb3JtVG9NYXNrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyx3QkFBd0IsRUFBRSxPQUFPLEVBQUUsYUFBYSxFQUFFLGlCQUFpQixFQUFDLE1BQU0sYUFBYSxDQUFDO0FBQ2hHLE9BQU8sRUFBQyxzQkFBc0IsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUduRCxNQUFNLENBQUMsTUFBTSxHQUFHLEdBQUcsOERBQThELENBQUM7QUFFbEYsTUFBTSxVQUFVLGFBQWEsQ0FDM0IsUUFBUSxHQUFHLEVBQUUsRUFDYixPQUEyQixFQUFFLEVBQzdCLFNBQWlDLEVBQUU7SUFFbkMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO1FBQ25CLHdFQUF3RTtRQUN4RSxtRUFBbUU7UUFDbkUsNEVBQTRFO1FBQzVFLDJDQUEyQztRQUMzQyxJQUFJLGFBQWEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO1lBQ3hCLCtDQUErQztZQUMvQyxJQUFJLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQztZQUU5Qix5R0FBeUc7WUFDekcsOEZBQThGO1lBQzlGLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzFCLENBQUM7YUFBTSxDQUFDO1lBQ04sTUFBTSxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN2QixDQUFDO0lBQ0gsQ0FBQztJQUVELHVEQUF1RDtJQUN2RCxNQUFNLEVBQ0osS0FBSyxHQUFHLElBQUksRUFDWixzQkFBc0IsR0FBRyxFQUFFLEVBQzNCLGVBQWUsR0FBRyxzQkFBc0IsRUFDeEMsV0FBVyxHQUFHLHdCQUF3QixDQUFDLElBQUksRUFBRSxlQUFlLENBQUMsRUFDN0Qsb0JBQW9CLEVBQ3BCLGlCQUFpQixFQUNsQixHQUFHLE1BQU0sQ0FBQztJQUVYLDBGQUEwRjtJQUMxRixNQUFNLGFBQWEsR0FBRyxLQUFLLEtBQUssS0FBSyxJQUFJLHNCQUFzQixLQUFLLFNBQVMsQ0FBQztJQUU5RSx5Q0FBeUM7SUFDekMsTUFBTSxjQUFjLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQztJQUN2QyxNQUFNLDRCQUE0QixHQUFHLHNCQUFzQixDQUFDLE1BQU0sQ0FBQztJQUNuRSxNQUFNLGlCQUFpQixHQUFHLFdBQVcsQ0FBQyxNQUFNLENBQUM7SUFDN0MsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUUvQixrR0FBa0c7SUFDbEcsTUFBTSxZQUFZLEdBQUcsY0FBYyxHQUFHLDRCQUE0QixDQUFDO0lBRW5FLHNGQUFzRjtJQUN0RixNQUFNLFVBQVUsR0FBRyxZQUFZLEdBQUcsQ0FBQyxDQUFDO0lBRXBDLCtGQUErRjtJQUMvRixNQUFNLGtCQUFrQixHQUFHLENBQUMsb0JBQW9CLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUUxRixvRkFBb0Y7SUFDcEYsTUFBTSxpQkFBaUIsR0FBRyxrQkFBa0IsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBRXRFLHNHQUFzRztJQUN0RyxtSEFBbUg7SUFDbkgsOEdBQThHO0lBQzlHLGtDQUFrQztJQUNsQyxFQUFFO0lBQ0YsaUdBQWlHO0lBQ2pHLGlHQUFpRztJQUNqRyx5RUFBeUU7SUFDekUsSUFBSSxpQkFBaUIsS0FBSyxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUM5QyxzRUFBc0U7UUFDdEUsSUFBSSw0QkFBNEIsR0FBRyxFQUFFLENBQUM7UUFFdEMsOEZBQThGO1FBQzlGLEtBQUssSUFBSSxDQUFDLEdBQUcsa0JBQWtCLEVBQUUsQ0FBQyxHQUFHLGlCQUFpQixFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDNUQsSUFBSSxXQUFXLENBQUMsQ0FBQyxDQUFDLEtBQUssZUFBZSxFQUFFLENBQUM7Z0JBQ3ZDLDRCQUE0QixJQUFJLGVBQWUsQ0FBQztZQUNsRCxDQUFDO1FBQ0gsQ0FBQztRQUVELDZHQUE2RztRQUM3Ryw4R0FBOEc7UUFDOUcsc0JBQXNCO1FBQ3RCLFFBQVEsR0FBRyxDQUNULFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLGtCQUFrQixDQUFDO1lBQ3JDLDRCQUE0QjtZQUM1QixRQUFRLENBQUMsS0FBSyxDQUFDLGtCQUFrQixFQUFFLGNBQWMsQ0FBQyxDQUNuRCxDQUFDO0lBQ0osQ0FBQztJQUVELDJHQUEyRztJQUMzRyw0R0FBNEc7SUFDNUcsMkRBQTJEO0lBQzNELE1BQU0sV0FBVyxHQUFHLFFBQVE7U0FDekIsS0FBSyxDQUFDLEVBQUUsQ0FBQztTQUNULEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLENBQUMsSUFBSSxrQkFBa0IsSUFBSSxDQUFDLEdBQUcsaUJBQWlCLEVBQUMsQ0FBQyxDQUFDLENBQUM7SUFFdkYsbUZBQW1GO0lBQ25GLCtGQUErRjtJQUMvRiwwRkFBMEY7SUFDMUYsa0ZBQWtGO0lBQ2xGLEtBQUssSUFBSSxDQUFDLEdBQUcsY0FBYyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDN0MsTUFBTSxFQUFDLElBQUksRUFBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUU5QixJQUFJLElBQUksS0FBSyxlQUFlLEVBQUUsQ0FBQztZQUM3QixNQUFNLFlBQVksR0FBRyxDQUFDLElBQUksa0JBQWtCLElBQUksNEJBQTRCLEtBQUssVUFBVSxDQUFDO1lBRTVGLElBQUksSUFBSSxLQUFLLFdBQVcsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO2dCQUNoRSxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUMzQixDQUFDO1FBQ0gsQ0FBQztJQUNILENBQUM7SUFFRCxxRkFBcUY7SUFDckYseUJBQXlCO0lBQ3pCLElBQUksY0FBYyxHQUFHLEVBQUUsQ0FBQztJQUN4QixJQUFJLGlCQUFpQixHQUFHLEtBQUssQ0FBQztJQUU5Qiw4RkFBOEY7SUFDOUYsZUFBZSxFQUFFLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxpQkFBaUIsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQzVELE1BQU0saUJBQWlCLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXpDLG9EQUFvRDtRQUNwRCxJQUFJLGlCQUFpQixLQUFLLGVBQWUsRUFBRSxDQUFDO1lBQzFDLDhFQUE4RTtZQUM5RSxJQUFJLFdBQVcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7Z0JBQzNCLGlGQUFpRjtnQkFDakYscURBQXFEO2dCQUNyRCxPQUFPLFdBQVcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7b0JBQzlCLGtGQUFrRjtvQkFDbEYsTUFBTSxHQUFHLEdBQUcsV0FBVyxDQUFDLEtBQUssRUFBRSxDQUFDO29CQUVoQyx3RkFBd0Y7b0JBQ3hGLHNGQUFzRjtvQkFDdEYsc0ZBQXNGO29CQUN0RixnRkFBZ0Y7b0JBQ2hGLElBQUksR0FBRyxFQUFFLElBQUksS0FBSyxlQUFlLElBQUksYUFBYSxLQUFLLElBQUksRUFBRSxDQUFDO3dCQUM1RCxjQUFjLElBQUksZUFBZSxDQUFDO3dCQUVsQyxzRUFBc0U7d0JBQ3RFLFNBQVMsZUFBZSxDQUFDO3dCQUUzQixvRkFBb0Y7d0JBQ3BGLHFEQUFxRDtvQkFDckQsQ0FBQzt5QkFBTSxJQUFJLEdBQUcsRUFBRSxJQUFJLElBQUssSUFBSSxDQUFDLENBQUMsQ0FBWSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQzt3QkFDM0QsK0ZBQStGO3dCQUMvRix1RkFBdUY7d0JBQ3ZGLHdCQUF3Qjt3QkFDeEIsSUFDRSxpQkFBaUIsS0FBSyxJQUFJOzRCQUMxQixHQUFHLEVBQUUsS0FBSyxLQUFLLEtBQUs7NEJBQ3BCLHNCQUFzQixLQUFLLEVBQUU7NEJBQzdCLEtBQUssS0FBSyxLQUFLOzRCQUNmLENBQUMsVUFBVSxFQUNYLENBQUM7NEJBQ0QsY0FBYyxJQUFJLEdBQUcsRUFBRSxJQUFJLENBQUM7d0JBQzlCLENBQUM7NkJBQU0sQ0FBQzs0QkFDTixzR0FBc0c7NEJBQ3RHLHNHQUFzRzs0QkFDdEcsOEVBQThFOzRCQUM5RSxFQUFFOzRCQUNGLHFHQUFxRzs0QkFDckcsd0dBQXdHOzRCQUN4RyxnRkFBZ0Y7NEJBQ2hGLE1BQU0saUJBQWlCLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQzs0QkFDN0MsSUFBSSxtQ0FBbUMsR0FBRyxJQUFJLENBQUM7NEJBRS9DLHdHQUF3Rzs0QkFDeEcsbUdBQW1HOzRCQUNuRyxxR0FBcUc7NEJBQ3JHLGtHQUFrRzs0QkFDbEcsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGlCQUFpQixFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7Z0NBQzNDLE1BQU0sUUFBUSxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQ0FFaEMsSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLGVBQWUsSUFBSSxRQUFRLENBQUMsS0FBSyxLQUFLLEtBQUssRUFBRSxDQUFDO29DQUNsRSxNQUFNO2dDQUNSLENBQUM7Z0NBRUQsSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLGVBQWUsRUFBRSxDQUFDO29DQUN0QyxtQ0FBbUMsR0FBRyxDQUFDLENBQUM7b0NBQ3hDLE1BQU07Z0NBQ1IsQ0FBQzs0QkFDSCxDQUFDOzRCQUVELG1HQUFtRzs0QkFDbkcsMEZBQTBGOzRCQUMxRixnQ0FBZ0M7NEJBQ2hDLElBQUksbUNBQW1DLEtBQUssSUFBSSxFQUFFLENBQUM7Z0NBQ2pELGNBQWMsSUFBSSxHQUFHLEVBQUUsSUFBSSxDQUFDO2dDQUM1QixXQUFXLENBQUMsTUFBTSxDQUFDLG1DQUFtQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dDQUU3RCxzR0FBc0c7Z0NBQ3RHLGNBQWM7NEJBQ2QsQ0FBQztpQ0FBTSxDQUFDO2dDQUNOLENBQUMsRUFBRSxDQUFDOzRCQUNOLENBQUM7d0JBQ0gsQ0FBQzt3QkFFRCw0RUFBNEU7d0JBQzVFLFNBQVMsZUFBZSxDQUFDO29CQUMzQixDQUFDO3lCQUFNLENBQUM7d0JBQ04saUJBQWlCLEdBQUcsSUFBSSxDQUFDO29CQUMzQixDQUFDO2dCQUNILENBQUM7WUFDSCxDQUFDO1lBRUQscUZBQXFGO1lBQ3JGLG9GQUFvRjtZQUNwRix3RkFBd0Y7WUFDeEYsRUFBRTtZQUNGLHFGQUFxRjtZQUNyRixJQUFJLGFBQWEsS0FBSyxLQUFLLEVBQUUsQ0FBQztnQkFDNUIsY0FBYyxJQUFJLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLGlCQUFpQixDQUFDLENBQUM7WUFDN0QsQ0FBQztZQUVELGVBQWU7WUFDZixNQUFNO1lBRVIsbUZBQW1GO1lBQ25GLHlEQUF5RDtRQUN6RCxDQUFDO2FBQU0sQ0FBQztZQUNOLGNBQWMsSUFBSSxpQkFBaUIsQ0FBQztRQUN0QyxDQUFDO0lBQ0gsQ0FBQztJQUVELHNGQUFzRjtJQUN0RixFQUFFO0lBQ0YsMkZBQTJGO0lBQzNGLDhGQUE4RjtJQUM5RixpR0FBaUc7SUFDakcsc0JBQXNCO0lBQ3RCLElBQUksYUFBYSxJQUFJLFVBQVUsS0FBSyxLQUFLLEVBQUUsQ0FBQztRQUMxQyxJQUFJLGdDQUFnQyxHQUFHLElBQUksQ0FBQztRQUU1QyxxRUFBcUU7UUFDckUsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUMvQyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsS0FBSyxlQUFlLEVBQUUsQ0FBQztnQkFDdkMsZ0NBQWdDLEdBQUcsQ0FBQyxDQUFDO1lBQ3ZDLENBQUM7UUFDSCxDQUFDO1FBRUQsSUFBSSxnQ0FBZ0MsS0FBSyxJQUFJLEVBQUUsQ0FBQztZQUM5Qyw2RkFBNkY7WUFDN0YsY0FBYyxHQUFHLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLGdDQUFnQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ2xGLENBQUM7YUFBTSxDQUFDO1lBQ04scUZBQXFGO1lBQ3JGLGlFQUFpRTtZQUNqRSxjQUFjLEdBQUcsRUFBRSxDQUFDO1FBQ3RCLENBQUM7SUFDSCxDQUFDO0lBRUQsT0FBTyxFQUFFLGNBQWMsRUFBRSxJQUFJLEVBQUUsRUFBRSxpQkFBaUIsRUFBRSxFQUFFLENBQUM7QUFDekQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Y29udmVydE1hc2tUb1BsYWNlaG9sZGVyLCBpc0FycmF5LCBpc01hc2tDcmVhdG9yLCBwcm9jZXNzQ2FyZXRUcmFwc30gZnJvbSAnLi91dGlsaXRpZXMnO1xuaW1wb3J0IHtkZWZhdWx0UGxhY2Vob2xkZXJDaGFyfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBNYXNrLCBDb25mb3JtQ29uZmlnLCBNYXNrQ3JlYXRvciwgQ29uZm9ybVJlc3BvbnNlIH0gZnJvbSAnLi90eXBpbmdzJztcblxuZXhwb3J0IGNvbnN0IGVyciA9ICdUZXh0LW1hc2s6Y29uZm9ybVRvTWFzazsgVGhlIG1hc2sgcHJvcGVydHkgbXVzdCBiZSBhbiBhcnJheS4nO1xuXG5leHBvcnQgZnVuY3Rpb24gY29uZm9ybVRvTWFzayhcbiAgcmF3VmFsdWUgPSAnJyxcbiAgbWFzazogTWFzayB8IE1hc2tDcmVhdG9yID0gW10sXG4gIGNvbmZpZzogUGFydGlhbDxDb25mb3JtQ29uZmlnPiA9IHt9XG4pOiBDb25mb3JtUmVzcG9uc2Uge1xuICBpZiAoIWlzQXJyYXkobWFzaykpIHtcbiAgICAvLyBJZiBzb21lb25lIHBhc3NlcyBhIGZ1bmN0aW9uIGFzIHRoZSBtYXNrIHByb3BlcnR5LCB3ZSBzaG91bGQgY2FsbCB0aGVcbiAgICAvLyBmdW5jdGlvbiB0byBnZXQgdGhlIG1hc2sgYXJyYXkgLSBOb3JtYWxseSB0aGlzIGlzIGhhbmRsZWQgYnkgdGhlXG4gICAgLy8gYGNyZWF0ZVRleHRNYXNrSW5wdXRFbGVtZW50OnVwZGF0ZWAgZnVuY3Rpb24gLSB0aGlzIGFsbG93cyBtYXNrIGZ1bmN0aW9uc1xuICAgIC8vIHRvIGJlIHVzZWQgZGlyZWN0bHkgd2l0aCBgY29uZm9ybVRvTWFza2BcbiAgICBpZiAoaXNNYXNrQ3JlYXRvcihtYXNrKSkge1xuICAgICAgLy8gY2FsbCB0aGUgbWFzayBmdW5jdGlvbiB0byBnZXQgdGhlIG1hc2sgYXJyYXlcbiAgICAgIG1hc2sgPSBtYXNrKHJhd1ZhbHVlLCBjb25maWcpO1xuXG4gICAgICAvLyBtYXNrIGZ1bmN0aW9ucyBjYW4gc2V0dXAgY2FyZXQgdHJhcHMgdG8gaGF2ZSBzb21lIGNvbnRyb2wgb3ZlciBob3cgdGhlIGNhcmV0IG1vdmVzLiBXZSBuZWVkIHRvIHByb2Nlc3NcbiAgICAgIC8vIHRoZSBtYXNrIGZvciBhbnkgY2FyZXQgdHJhcHMuIGBwcm9jZXNzQ2FyZXRUcmFwc2Agd2lsbCByZW1vdmUgdGhlIGNhcmV0IHRyYXBzIGZyb20gdGhlIG1hc2tcbiAgICAgIHByb2Nlc3NDYXJldFRyYXBzKG1hc2spO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cblxuICAvLyBUaGVzZSBjb25maWd1cmF0aW9ucyB0ZWxsIHVzIGhvdyB0byBjb25mb3JtIHRoZSBtYXNrXG4gIGNvbnN0IHtcbiAgICBndWlkZSA9IHRydWUsXG4gICAgcHJldmlvdXNDb25mb3JtZWRWYWx1ZSA9ICcnLFxuICAgIHBsYWNlaG9sZGVyQ2hhciA9IGRlZmF1bHRQbGFjZWhvbGRlckNoYXIsXG4gICAgcGxhY2Vob2xkZXIgPSBjb252ZXJ0TWFza1RvUGxhY2Vob2xkZXIobWFzaywgcGxhY2Vob2xkZXJDaGFyKSxcbiAgICBjdXJyZW50Q2FyZXRQb3NpdGlvbixcbiAgICBrZWVwQ2hhclBvc2l0aW9uc1xuICB9ID0gY29uZmlnO1xuXG4gIC8vIFRoZSBjb25maWdzIGJlbG93IGluZGljYXRlIHRoYXQgdGhlIHVzZXIgd2FudHMgdGhlIGFsZ29yaXRobSB0byB3b3JrIGluICpubyBndWlkZSogbW9kZVxuICBjb25zdCBzdXBwcmVzc0d1aWRlID0gZ3VpZGUgPT09IGZhbHNlICYmIHByZXZpb3VzQ29uZm9ybWVkVmFsdWUgIT09IHVuZGVmaW5lZDtcblxuICAvLyBDYWxjdWxhdGUgbGVuZ3RocyBvbmNlIGZvciBwZXJmb3JtYW5jZVxuICBjb25zdCByYXdWYWx1ZUxlbmd0aCA9IHJhd1ZhbHVlLmxlbmd0aDtcbiAgY29uc3QgcHJldmlvdXNDb25mb3JtZWRWYWx1ZUxlbmd0aCA9IHByZXZpb3VzQ29uZm9ybWVkVmFsdWUubGVuZ3RoO1xuICBjb25zdCBwbGFjZWhvbGRlckxlbmd0aCA9IHBsYWNlaG9sZGVyLmxlbmd0aDtcbiAgY29uc3QgbWFza0xlbmd0aCA9IG1hc2subGVuZ3RoO1xuXG4gIC8vIFRoaXMgdGVsbHMgdXMgdGhlIG51bWJlciBvZiBlZGl0ZWQgY2hhcmFjdGVycyBhbmQgdGhlIGRpcmVjdGlvbiBpbiB3aGljaCB0aGV5IHdlcmUgZWRpdGVkICgrLy0pXG4gIGNvbnN0IGVkaXREaXN0YW5jZSA9IHJhd1ZhbHVlTGVuZ3RoIC0gcHJldmlvdXNDb25mb3JtZWRWYWx1ZUxlbmd0aDtcblxuICAvLyBJbiAqbm8gZ3VpZGUqIG1vZGUsIHdlIG5lZWQgdG8ga25vdyBpZiB0aGUgdXNlciBpcyB0cnlpbmcgdG8gYWRkIGEgY2hhcmFjdGVyIG9yIG5vdFxuICBjb25zdCBpc0FkZGl0aW9uID0gZWRpdERpc3RhbmNlID4gMDtcblxuICAvLyBUZWxscyB1cyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNoYW5nZS4gRm9yICg0MzgpIDM5NC00OTM4IHRvICgzOCkgMzk0LTQ5MzgsIHRoYXQgd291bGQgYmUgMVxuICBjb25zdCBpbmRleE9mRmlyc3RDaGFuZ2UgPSAoY3VycmVudENhcmV0UG9zaXRpb24gfHwgMCkgKyAoaXNBZGRpdGlvbiA/IC1lZGl0RGlzdGFuY2UgOiAwKTtcblxuICAvLyBXZSdyZSBhbHNvIGdvbm5hIG5lZWQgdGhlIGluZGV4IG9mIGxhc3QgY2hhbmdlLCB3aGljaCB3ZSBjYW4gZGVyaXZlIGFzIGZvbGxvd3MuLi5cbiAgY29uc3QgaW5kZXhPZkxhc3RDaGFuZ2UgPSBpbmRleE9mRmlyc3RDaGFuZ2UgKyBNYXRoLmFicyhlZGl0RGlzdGFuY2UpO1xuXG4gIC8vIElmIGBjb25mb3JtVG9NYXNrYCBpcyBjb25maWd1cmVkIHRvIGtlZXAgY2hhcmFjdGVyIHBvc2l0aW9ucywgdGhhdCBpcywgZm9yIG1hc2sgMTExLCBwcmV2aW91cyB2YWx1ZVxuICAvLyBfMl8gYW5kIHJhdyB2YWx1ZSAzXzJfLCB0aGUgbmV3IGNvbmZvcm1lZCB2YWx1ZSBzaG91bGQgYmUgMzJfLCBub3QgM18yIChkZWZhdWx0IGJlaGF2aW9yKS4gVGhhdCdzIGluIHRoZSBjYXNlIG9mXG4gIC8vIGFkZGl0aW9uLiBBbmQgaW4gdGhlIGNhc2Ugb2YgZGVsZXRpb24sIHByZXZpb3VzIHZhbHVlIF8yMywgcmF3IHZhbHVlIF8zLCB0aGUgbmV3IGNvbmZvcm1lZCBzdHJpbmcgc2hvdWxkIGJlXG4gIC8vIF9fMywgbm90IF8zXyAoZGVmYXVsdCBiZWhhdmlvcilcbiAgLy9cbiAgLy8gVGhlIG5leHQgYmxvY2sgb2YgbG9naWMgaGFuZGxlcyBrZWVwaW5nIGNoYXJhY3RlciBwb3NpdGlvbnMgZm9yIHRoZSBjYXNlIG9mIGRlbGV0aW9uLiAoS2VlcGluZ1xuICAvLyBjaGFyYWN0ZXIgcG9zaXRpb25zIGZvciB0aGUgY2FzZSBvZiBhZGRpdGlvbiBpcyBmdXJ0aGVyIGRvd24gc2luY2UgaXQgaXMgaGFuZGxlZCBkaWZmZXJlbnRseS4pXG4gIC8vIFRvIGRvIHRoaXMsIHdlIHdhbnQgdG8gY29tcGVuc2F0ZSBmb3IgYWxsIGNoYXJhY3RlcnMgdGhhdCB3ZXJlIGRlbGV0ZWRcbiAgaWYgKGtlZXBDaGFyUG9zaXRpb25zID09PSB0cnVlICYmICFpc0FkZGl0aW9uKSB7XG4gICAgLy8gV2Ugd2lsbCBiZSBzdG9yaW5nIHRoZSBuZXcgcGxhY2Vob2xkZXIgY2hhcmFjdGVycyBpbiB0aGlzIHZhcmlhYmxlLlxuICAgIGxldCBjb21wZW5zYXRpbmdQbGFjZWhvbGRlckNoYXJzID0gJyc7XG5cbiAgICAvLyBGb3IgZXZlcnkgY2hhcmFjdGVyIHRoYXQgd2FzIGRlbGV0ZWQgZnJvbSBhIHBsYWNlaG9sZGVyIHBvc2l0aW9uLCB3ZSBhZGQgYSBwbGFjZWhvbGRlciBjaGFyXG4gICAgZm9yIChsZXQgaSA9IGluZGV4T2ZGaXJzdENoYW5nZTsgaSA8IGluZGV4T2ZMYXN0Q2hhbmdlOyBpKyspIHtcbiAgICAgIGlmIChwbGFjZWhvbGRlcltpXSA9PT0gcGxhY2Vob2xkZXJDaGFyKSB7XG4gICAgICAgIGNvbXBlbnNhdGluZ1BsYWNlaG9sZGVyQ2hhcnMgKz0gcGxhY2Vob2xkZXJDaGFyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vdyB3ZSB0cmljayBvdXIgYWxnb3JpdGhtIGJ5IG1vZGlmeWluZyB0aGUgcmF3IHZhbHVlIHRvIG1ha2UgaXQgY29udGFpbiBhZGRpdGlvbmFsIHBsYWNlaG9sZGVyIGNoYXJhY3RlcnNcbiAgICAvLyBUaGF0IHdheSB3aGVuIHRoZSB3ZSBzdGFydCBsYXlpbmcgdGhlIGNoYXJhY3RlcnMgYWdhaW4gb24gdGhlIG1hc2ssIGl0IHdpbGwga2VlcCB0aGUgbm9uLWRlbGV0ZWQgY2hhcmFjdGVyc1xuICAgIC8vIGluIHRoZWlyIHBvc2l0aW9ucy5cbiAgICByYXdWYWx1ZSA9IChcbiAgICAgIHJhd1ZhbHVlLnNsaWNlKDAsIGluZGV4T2ZGaXJzdENoYW5nZSkgK1xuICAgICAgY29tcGVuc2F0aW5nUGxhY2Vob2xkZXJDaGFycyArXG4gICAgICByYXdWYWx1ZS5zbGljZShpbmRleE9mRmlyc3RDaGFuZ2UsIHJhd1ZhbHVlTGVuZ3RoKVxuICAgICk7XG4gIH1cblxuICAvLyBDb252ZXJ0IGByYXdWYWx1ZWAgc3RyaW5nIHRvIGFuIGFycmF5LCBhbmQgbWFyayBjaGFyYWN0ZXJzIGJhc2VkIG9uIHdoZXRoZXIgdGhleSBhcmUgbmV3bHkgYWRkZWQgb3IgaGF2ZVxuICAvLyBleGlzdGVkIGluIHRoZSBwcmV2aW91cyBjb25mb3JtZWQgdmFsdWUuIElkZW50aWZ5aW5nIG5ldyBhbmQgb2xkIGNoYXJhY3RlcnMgaXMgbmVlZGVkIGZvciBgY29uZm9ybVRvTWFza2BcbiAgLy8gdG8gd29yayBpZiBpdCBpcyBjb25maWd1cmVkIHRvIGtlZXAgY2hhcmFjdGVyIHBvc2l0aW9ucy5cbiAgY29uc3QgcmF3VmFsdWVBcnIgPSByYXdWYWx1ZVxuICAgIC5zcGxpdCgnJylcbiAgICAubWFwKChjaGFyLCBpKSA9PiAoe2NoYXIsIGlzTmV3OiBpID49IGluZGV4T2ZGaXJzdENoYW5nZSAmJiBpIDwgaW5kZXhPZkxhc3RDaGFuZ2V9KSk7XG5cbiAgLy8gVGhlIGxvb3AgYmVsb3cgcmVtb3ZlcyBtYXNraW5nIGNoYXJhY3RlcnMgZnJvbSB1c2VyIGlucHV0LiBGb3IgZXhhbXBsZSwgZm9yIG1hc2tcbiAgLy8gYDAwICgxMTEpYCwgdGhlIHBsYWNlaG9sZGVyIHdvdWxkIGJlIGAwMCAoX19fKWAuIElmIHVzZXIgaW5wdXQgaXMgYDAwICgyMzQpYCwgdGhlIGxvb3AgYmVsb3dcbiAgLy8gd291bGQgcmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIGJ1dCBgMjM0YCBmcm9tIHRoZSBgcmF3VmFsdWVBcnJgLiBUaGUgcmVzdCBvZiB0aGUgYWxnb3JpdGhtXG4gIC8vIHRoZW4gd291bGQgbGF5IGAyMzRgIG9uIHRvcCBvZiB0aGUgYXZhaWxhYmxlIHBsYWNlaG9sZGVyIHBvc2l0aW9ucyBpbiB0aGUgbWFzay5cbiAgZm9yIChsZXQgaSA9IHJhd1ZhbHVlTGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCB7Y2hhcn0gPSByYXdWYWx1ZUFycltpXTtcblxuICAgIGlmIChjaGFyICE9PSBwbGFjZWhvbGRlckNoYXIpIHtcbiAgICAgIGNvbnN0IHNob3VsZE9mZnNldCA9IGkgPj0gaW5kZXhPZkZpcnN0Q2hhbmdlICYmIHByZXZpb3VzQ29uZm9ybWVkVmFsdWVMZW5ndGggPT09IG1hc2tMZW5ndGg7XG5cbiAgICAgIGlmIChjaGFyID09PSBwbGFjZWhvbGRlclsoc2hvdWxkT2Zmc2V0KSA/IGkgLSBlZGl0RGlzdGFuY2UgOiBpXSkge1xuICAgICAgICByYXdWYWx1ZUFyci5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVGhpcyBpcyB0aGUgdmFyaWFibGUgdGhhdCB3ZSB3aWxsIGJlIGZpbGxpbmcgd2l0aCBjaGFyYWN0ZXJzIGFzIHdlIGZpZ3VyZSB0aGVtIG91dFxuICAvLyBpbiB0aGUgYWxnb3JpdGhtIGJlbG93XG4gIGxldCBjb25mb3JtZWRWYWx1ZSA9ICcnO1xuICBsZXQgc29tZUNoYXJzUmVqZWN0ZWQgPSBmYWxzZTtcblxuICAvLyBPaywgc28gZmlyc3Qgd2UgbG9vcCB0aHJvdWdoIHRoZSBwbGFjZWhvbGRlciBsb29raW5nIGZvciBwbGFjZWhvbGRlciBjaGFyYWN0ZXJzIHRvIGZpbGwgdXAuXG4gIHBsYWNlaG9sZGVyTG9vcDogZm9yIChsZXQgaSA9IDA7IGkgPCBwbGFjZWhvbGRlckxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhckluUGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcltpXTtcblxuICAgIC8vIFdlIHNlZSBvbmUuIExldCdzIGZpbmQgb3V0IHdoYXQgd2UgY2FuIHB1dCBpbiBpdC5cbiAgICBpZiAoY2hhckluUGxhY2Vob2xkZXIgPT09IHBsYWNlaG9sZGVyQ2hhcikge1xuICAgICAgLy8gQnV0IGJlZm9yZSB0aGF0LCBkbyB3ZSBhY3R1YWxseSBoYXZlIGFueSB1c2VyIGNoYXJhY3RlcnMgdGhhdCBuZWVkIGEgcGxhY2U/XG4gICAgICBpZiAocmF3VmFsdWVBcnIubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBXZSB3aWxsIGtlZXAgY2hpcHBpbmcgYXdheSBhdCB1c2VyIGlucHV0IHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIGNoYXJhY3RlcnNcbiAgICAgICAgLy8gb3Igd2UgZmluZCBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyIHRoYXQgd2UgY2FuIG1hcC5cbiAgICAgICAgd2hpbGUgKHJhd1ZhbHVlQXJyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBMZXQncyByZXRyaWV2ZSB0aGUgZmlyc3QgdXNlciBjaGFyYWN0ZXIgaW4gdGhlIHF1ZXVlIG9mIGNoYXJhY3RlcnMgd2UgaGF2ZSBsZWZ0XG4gICAgICAgICAgY29uc3QgcmVzID0gcmF3VmFsdWVBcnIuc2hpZnQoKTtcblxuICAgICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgd2UgZ290IGZyb20gdGhlIHVzZXIgaW5wdXQgaXMgYSBwbGFjZWhvbGRlciBjaGFyYWN0ZXIgKHdoaWNoIGhhcHBlbnNcbiAgICAgICAgICAvLyByZWd1bGFybHkgYmVjYXVzZSB1c2VyIGlucHV0IGNvdWxkIGJlIHNvbWV0aGluZyBsaWtlICg1NDApIDkwXy1fX19fLCB3aGljaCBpbmNsdWRlc1xuICAgICAgICAgIC8vIGEgYnVuY2ggb2YgYF9gIHdoaWNoIGFyZSBwbGFjZWhvbGRlciBjaGFyYWN0ZXJzKSBhbmQgd2UgYXJlIG5vdCBpbiAqbm8gZ3VpZGUqIG1vZGUsXG4gICAgICAgICAgLy8gdGhlbiB3ZSBtYXAgdGhpcyBwbGFjZWhvbGRlciBjaGFyYWN0ZXIgdG8gdGhlIGN1cnJlbnQgc3BvdCBpbiB0aGUgcGxhY2Vob2xkZXJcbiAgICAgICAgICBpZiAocmVzPy5jaGFyID09PSBwbGFjZWhvbGRlckNoYXIgJiYgc3VwcHJlc3NHdWlkZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uZm9ybWVkVmFsdWUgKz0gcGxhY2Vob2xkZXJDaGFyO1xuXG4gICAgICAgICAgICAvLyBBbmQgd2UgZ28gdG8gZmluZCB0aGUgbmV4dCBwbGFjZWhvbGRlciBjaGFyYWN0ZXIgdGhhdCBuZWVkcyBmaWxsaW5nXG4gICAgICAgICAgICBjb250aW51ZSBwbGFjZWhvbGRlckxvb3A7XG5cbiAgICAgICAgICAvLyBFbHNlIGlmLCB0aGUgY2hhcmFjdGVyIHdlIGdvdCBmcm9tIHRoZSB1c2VyIGlucHV0IGlzIG5vdCBhIHBsYWNlaG9sZGVyLCBsZXQncyBzZWVcbiAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgbWFzayBjYW4gYWNjZXB0IGl0LlxuICAgICAgICAgIH0gZWxzZSBpZiAocmVzPy5jaGFyICYmIChtYXNrW2ldIGFzIFJlZ0V4cCkudGVzdChyZXMuY2hhcikpIHtcbiAgICAgICAgICAgIC8vIHdlIG1hcCB0aGUgY2hhcmFjdGVyIGRpZmZlcmVudGx5IGJhc2VkIG9uIHdoZXRoZXIgd2UgYXJlIGtlZXBpbmcgY2hhcmFjdGVyIHBvc2l0aW9ucyBvciBub3QuXG4gICAgICAgICAgICAvLyBJZiBhbnkgb2YgdGhlIGNvbmRpdGlvbnMgYmVsb3cgYXJlIG1ldCwgd2Ugc2ltcGx5IG1hcCB0aGUgcmF3IHZhbHVlIGNoYXJhY3RlciB0byB0aGVcbiAgICAgICAgICAgIC8vIHBsYWNlaG9sZGVyIHBvc2l0aW9uLlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBrZWVwQ2hhclBvc2l0aW9ucyAhPT0gdHJ1ZSB8fFxuICAgICAgICAgICAgICByZXM/LmlzTmV3ID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgICBwcmV2aW91c0NvbmZvcm1lZFZhbHVlID09PSAnJyB8fFxuICAgICAgICAgICAgICBndWlkZSA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgICAgIWlzQWRkaXRpb25cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjb25mb3JtZWRWYWx1ZSArPSByZXM/LmNoYXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBXZSBlbnRlciB0aGlzIGJsb2NrIG9mIGNvZGUgaWYgd2UgYXJlIHRyeWluZyB0byBrZWVwIGNoYXJhY3RlciBwb3NpdGlvbnMgYW5kIG5vbmUgb2YgdGhlIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgLy8gYWJvdmUgaXMgbWV0LiBJbiB0aGlzIGNhc2UsIHdlIG5lZWQgdG8gc2VlIGlmIHRoZXJlJ3MgYW4gYXZhaWxhYmxlIHNwb3QgZm9yIHRoZSByYXcgdmFsdWUgY2hhcmFjdGVyXG4gICAgICAgICAgICAgIC8vIHRvIGJlIG1hcHBlZCB0by4gSWYgd2UgY291bGRuJ3QgZmluZCBhIHNwb3QsIHdlIHdpbGwgZGlzY2FyZCB0aGUgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgZm9yIG1hc2sgYDExMTFgLCBwcmV2aW91cyBjb25mb3JtZWQgdmFsdWUgYF8yX19gLCByYXcgdmFsdWUgYDk0Ml8yX19gLiBXZSBjYW4gbWFwIHRoZVxuICAgICAgICAgICAgICAvLyBgOWAsIHRvIHRoZSBmaXJzdCBhdmFpbGFibGUgcGxhY2Vob2xkZXIgcG9zaXRpb24sIGJ1dCB0aGVuLCB0aGVyZSBhcmUgbm8gbW9yZSBzcG90cyBhdmFpbGFibGUgZm9yIHRoZVxuICAgICAgICAgICAgICAvLyBgNGAgYW5kIGAyYC4gU28sIHdlIGRpc2NhcmQgdGhlbSBhbmQgZW5kIHVwIHdpdGggYSBjb25mb3JtZWQgdmFsdWUgb2YgYDkyX19gLlxuICAgICAgICAgICAgICBjb25zdCByYXdWYWx1ZUFyckxlbmd0aCA9IHJhd1ZhbHVlQXJyLmxlbmd0aDtcbiAgICAgICAgICAgICAgbGV0IGluZGV4T2ZOZXh0QXZhaWxhYmxlUGxhY2Vob2xkZXJDaGFyID0gbnVsbDtcblxuICAgICAgICAgICAgICAvLyBMZXQncyBsb29wIHRocm91Z2ggdGhlIHJlbWFpbmluZyByYXcgdmFsdWUgY2hhcmFjdGVycy4gV2UgYXJlIGxvb2tpbmcgZm9yIGVpdGhlciBhIHN1aXRhYmxlIHNwb3QsIGllLFxuICAgICAgICAgICAgICAvLyBhIHBsYWNlaG9sZGVyIGNoYXJhY3RlciBvciBhIG5vbi1zdWl0YWJsZSBzcG90LCBpZSwgYSBub24tcGxhY2Vob2xkZXIgY2hhcmFjdGVyIHRoYXQgaXMgbm90IG5ldy5cbiAgICAgICAgICAgICAgLy8gSWYgd2Ugc2VlIGEgc3VpdGFibGUgc3BvdCBmaXJzdCwgd2Ugc3RvcmUgaXRzIHBvc2l0aW9uIGFuZCBleGl0IHRoZSBsb29wLiBJZiB3ZSBzZWUgYSBub24tc3VpdGFibGVcbiAgICAgICAgICAgICAgLy8gc3BvdCBmaXJzdCwgd2UgZXhpdCB0aGUgbG9vcCBhbmQgb3VyIGBpbmRleE9mTmV4dEF2YWlsYWJsZVBsYWNlaG9sZGVyQ2hhcmAgd2lsbCBzdGF5IGFzIGBudWxsYC5cbiAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByYXdWYWx1ZUFyckxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhckRhdGEgPSByYXdWYWx1ZUFycltrXTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGFyRGF0YS5jaGFyICE9PSBwbGFjZWhvbGRlckNoYXIgJiYgY2hhckRhdGEuaXNOZXcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckRhdGEuY2hhciA9PT0gcGxhY2Vob2xkZXJDaGFyKSB7XG4gICAgICAgICAgICAgICAgICBpbmRleE9mTmV4dEF2YWlsYWJsZVBsYWNlaG9sZGVyQ2hhciA9IGs7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBJZiBgaW5kZXhPZk5leHRBdmFpbGFibGVQbGFjZWhvbGRlckNoYXJgIGlzIG5vdCBgbnVsbGAsIHRoYXQgbWVhbnMgdGhlIGNoYXJhY3RlciBpcyBub3QgYmxvY2tlZC5cbiAgICAgICAgICAgICAgLy8gV2UgY2FuIG1hcCBpdC4gQW5kIHRvIGtlZXAgdGhlIGNoYXJhY3RlciBwb3NpdGlvbnMsIHdlIHJlbW92ZSB0aGUgcGxhY2Vob2xkZXIgY2hhcmFjdGVyXG4gICAgICAgICAgICAgIC8vIGZyb20gdGhlIHJlbWFpbmluZyBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgIGlmIChpbmRleE9mTmV4dEF2YWlsYWJsZVBsYWNlaG9sZGVyQ2hhciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZvcm1lZFZhbHVlICs9IHJlcz8uY2hhcjtcbiAgICAgICAgICAgICAgICByYXdWYWx1ZUFyci5zcGxpY2UoaW5kZXhPZk5leHRBdmFpbGFibGVQbGFjZWhvbGRlckNoYXIsIDEpO1xuXG4gICAgICAgICAgICAgIC8vIElmIGBpbmRleE9mTmV4dEF2YWlsYWJsZVBsYWNlaG9sZGVyQ2hhcmAgaXMgYG51bGxgLCB0aGF0IG1lYW5zIHRoZSBjaGFyYWN0ZXIgaXMgYmxvY2tlZC4gV2UgaGF2ZSB0b1xuICAgICAgICAgICAgICAvLyBkaXNjYXJkIGl0LlxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSd2ZSBtYXBwZWQgdGhpcyBwbGFjZWhvbGRlciBwb3NpdGlvbi4gV2UgbW92ZSBvbiB0byB0aGUgbmV4dCBvbmUuXG4gICAgICAgICAgICBjb250aW51ZSBwbGFjZWhvbGRlckxvb3A7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvbWVDaGFyc1JlamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gV2UgcmVhY2ggdGhpcyBwb2ludCB3aGVuIHdlJ3ZlIG1hcHBlZCBhbGwgdGhlIHVzZXIgaW5wdXQgY2hhcmFjdGVycyB0byBwbGFjZWhvbGRlclxuICAgICAgLy8gcG9zaXRpb25zIGluIHRoZSBtYXNrLiBJbiAqZ3VpZGUqIG1vZGUsIHdlIGFwcGVuZCB0aGUgbGVmdCBvdmVyIGNoYXJhY3RlcnMgaW4gdGhlXG4gICAgICAvLyBwbGFjZWhvbGRlciB0byB0aGUgYGNvbmZvcm1lZFN0cmluZ2AsIGJ1dCBpbiAqbm8gZ3VpZGUqIG1vZGUsIHdlIGRvbid0IHdhbm5hIGRvIHRoYXQuXG4gICAgICAvL1xuICAgICAgLy8gVGhhdCBpcywgZm9yIG1hc2sgYCgxMTEpYCBhbmQgdXNlciBpbnB1dCBgMmAsIHdlIHdhbnQgdG8gcmV0dXJuIGAoMmAsIG5vdCBgKDJfXylgLlxuICAgICAgaWYgKHN1cHByZXNzR3VpZGUgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbmZvcm1lZFZhbHVlICs9IHBsYWNlaG9sZGVyLnN1YnN0cihpLCBwbGFjZWhvbGRlckxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFuZCB3ZSBicmVha1xuICAgICAgYnJlYWs7XG5cbiAgICAvLyBFbHNlLCB0aGUgY2hhckluUGxhY2Vob2xkZXIgaXMgbm90IGEgcGxhY2Vob2xkZXJDaGFyLiBUaGF0IGlzLCB3ZSBjYW5ub3QgZmlsbCBpdFxuICAgIC8vIHdpdGggdXNlciBpbnB1dC4gU28gd2UganVzdCBtYXAgaXQgdG8gdGhlIGZpbmFsIG91dHB1dFxuICAgIH0gZWxzZSB7XG4gICAgICBjb25mb3JtZWRWYWx1ZSArPSBjaGFySW5QbGFjZWhvbGRlcjtcbiAgICB9XG4gIH1cblxuICAvLyBUaGUgZm9sbG93aW5nIGxvZ2ljIGlzIG5lZWRlZCB0byBkZWFsIHdpdGggdGhlIGNhc2Ugb2YgZGVsZXRpb24gaW4gKm5vIGd1aWRlKiBtb2RlLlxuICAvL1xuICAvLyBDb25zaWRlciB0aGUgc2lsbHkgbWFzayBgKDExMSkgLy8vIDFgLiBXaGF0IGlmIHVzZXIgdHJpZXMgdG8gZGVsZXRlIHRoZSBsYXN0IHBsYWNlaG9sZGVyXG4gIC8vIHBvc2l0aW9uPyBTb21ldGhpbmcgbGlrZSBgKDU4OSkgLy8vIGAuIFdlIHdhbnQgdG8gY29uZm9ybSB0aGF0IHRvIGAoNTg5YC4gTm90IGAoNTg5KSAvLy8gYC5cbiAgLy8gVGhhdCdzIHdoeSB0aGUgbG9naWMgYmVsb3cgZmluZHMgdGhlIGxhc3QgZmlsbGVkIHBsYWNlaG9sZGVyIGNoYXJhY3RlciwgYW5kIHJlbW92ZXMgZXZlcnl0aGluZ1xuICAvLyBmcm9tIHRoYXQgcG9pbnQgb24uXG4gIGlmIChzdXBwcmVzc0d1aWRlICYmIGlzQWRkaXRpb24gPT09IGZhbHNlKSB7XG4gICAgbGV0IGluZGV4T2ZMYXN0RmlsbGVkUGxhY2Vob2xkZXJDaGFyID0gbnVsbDtcblxuICAgIC8vIEZpbmQgdGhlIGxhc3QgZmlsbGVkIHBsYWNlaG9sZGVyIHBvc2l0aW9uIGFuZCBzdWJzdHJpbmcgZnJvbSB0aGVyZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29uZm9ybWVkVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwbGFjZWhvbGRlcltpXSA9PT0gcGxhY2Vob2xkZXJDaGFyKSB7XG4gICAgICAgIGluZGV4T2ZMYXN0RmlsbGVkUGxhY2Vob2xkZXJDaGFyID0gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5kZXhPZkxhc3RGaWxsZWRQbGFjZWhvbGRlckNoYXIgIT09IG51bGwpIHtcbiAgICAgIC8vIFdlIHN1YnN0cmluZyBmcm9tIHRoZSBiZWdpbm5pbmcgdW50aWwgdGhlIHBvc2l0aW9uIGFmdGVyIHRoZSBsYXN0IGZpbGxlZCBwbGFjZWhvbGRlciBjaGFyLlxuICAgICAgY29uZm9ybWVkVmFsdWUgPSBjb25mb3JtZWRWYWx1ZS5zdWJzdHIoMCwgaW5kZXhPZkxhc3RGaWxsZWRQbGFjZWhvbGRlckNoYXIgKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UgY291bGRuJ3QgZmluZCBgaW5kZXhPZkxhc3RGaWxsZWRQbGFjZWhvbGRlckNoYXJgIHRoYXQgbWVhbnMgdGhlIHVzZXIgZGVsZXRlZFxuICAgICAgLy8gdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgbWFzay4gU28gd2UgcmV0dXJuIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgIGNvbmZvcm1lZFZhbHVlID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgY29uZm9ybWVkVmFsdWUsIG1ldGE6IHsgc29tZUNoYXJzUmVqZWN0ZWQgfSB9O1xufVxuIl19