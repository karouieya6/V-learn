import { adjustCaretPosition } from './adjustCaretPosition';
import { conformToMask } from './conformToMask';
import { convertMaskToPlaceholder, isString, isNumber, processCaretTraps, isMaskObject } from './utilities';
import { defaultPlaceholderChar } from './constants';
const isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);
const defer = typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame : setTimeout;
export function createTextMaskInputElement(config) {
    // Anything that we will need to keep between `update` calls, we will store in this `state` object.
    const state = {
        previousConformedValue: undefined,
        previousPlaceholder: undefined
    };
    return {
        state,
        // `update` is called by framework components whenever they want to update the `value` of the input element.
        // The caller can send a `rawValue` to be conformed and set on the input element. However, the default use-case
        // is for this to be read from the `inputElement` directly.
        update(rawValue, { inputElement, mask: providedMask, guide, pipe, placeholderChar = defaultPlaceholderChar, keepCharPositions = false, showMask = false } = config) {
            // if `rawValue` is `undefined`, read from the `inputElement`
            if (typeof rawValue === 'undefined') {
                rawValue = inputElement.value;
            }
            // If `rawValue` equals `state.previousConformedValue`, we don't need to change anything. So, we return.
            // This check is here to handle controlled framework components that repeat the `update` call on every render.
            if (rawValue === state.previousConformedValue) {
                return;
            }
            // We don't know what the mask would be yet. If it is an array, we take it as is, but if it's a function, we will
            // have to call that function to get the mask array.
            let mask;
            // Text Mask accepts masks that are a combination of a `mask` and a `pipe` that work together. If such a `mask` is
            // passed, we destructure it below, so the rest of the code can work normally as if a separate `mask` and a `pipe`
            // were passed.
            if (isMaskObject(providedMask)) {
                pipe = providedMask.pipe;
                providedMask = providedMask.mask;
            }
            // The `placeholder` is an essential piece of how Text Mask works. For a mask like `(111)`, the placeholder would
            // be `(___)` if the `placeholderChar` is set to `_`.
            let placeholder = '';
            // If the provided mask is an array, we can call `convertMaskToPlaceholder` here once and we'll always have the
            // correct `placeholder`.
            if (providedMask instanceof Array) {
                placeholder = convertMaskToPlaceholder(providedMask, placeholderChar);
            }
            // In framework components that support reactivity, it's possible to turn off masking by passing
            // `false` for `mask` after initialization. See https://github.com/text-mask/text-mask/pull/359
            if (!providedMask) {
                return;
            }
            // We check the provided `rawValue` before moving further.
            // If it's something we can't work with `getSafeRawValue` will throw.
            const safeRawValue = getSafeRawValue(rawValue);
            // `selectionEnd` indicates to us where the caret position is after the user has typed into the input
            const { selectionEnd: currentCaretPosition } = inputElement;
            // We need to know what the `previousConformedValue` and `previousPlaceholder` is from the previous `update` call
            const { previousConformedValue, previousPlaceholder } = state;
            let caretTrapIndexes = [];
            // If the `providedMask` is a function. We need to call it at every `update` to get the `mask` array.
            // Then we also need to get the `placeholder`
            if (typeof providedMask === 'function') {
                mask = providedMask(safeRawValue, { currentCaretPosition, previousConformedValue, placeholderChar });
                // disable masking if `mask` is `false`
                if (!mask) {
                    return;
                }
                // mask functions can setup caret traps to have some control over how the caret moves. We need to process
                // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask and return
                // the indexes of the caret traps.
                caretTrapIndexes = processCaretTraps(mask);
                placeholder = convertMaskToPlaceholder(mask, placeholderChar);
            }
            else {
                // if the `providedMask` is not a function, we just use it as-is.
                mask = providedMask;
            }
            // The following object will be passed to `conformToMask` to determine how the `rawValue` will be conformed
            const conformToMaskConfig = {
                previousConformedValue,
                guide,
                placeholder,
                placeholderChar,
                pipe,
                currentCaretPosition,
                keepCharPositions
            };
            // `conformToMask` returns `conformedValue` as part of an object for future API flexibility
            const { conformedValue } = conformToMask(safeRawValue, mask, conformToMaskConfig);
            // The following few lines are to support the `pipe` feature.
            let pipeResults = {};
            // we need to know which conformed value to use, the one returned by the pipe or the one
            // returned by `conformToMask`.
            let finalConformedValue = conformedValue;
            // If `pipe` is a function, we call it.
            if (typeof pipe === 'function') {
                // `pipe` receives the `conformedValue` and the configurations with which `conformToMask` was called.
                pipeResults = pipe(conformedValue, { rawValue: safeRawValue, ...conformToMaskConfig });
                // `pipeResults` should be an object. But as a convenience, we allow the pipe author to just return `false` to
                // indicate rejection. Or return just a string when there are no piped characters.
                // If the `pipe` returns `false` or a string, the block below turns it into an object that the rest
                // of the code can work with.
                if (pipeResults === false) {
                    // If the `pipe` rejects `conformedValue`, we use the `previousConformedValue`, and set `rejected` to `true`.
                    pipeResults = { value: previousConformedValue, rejected: true };
                    finalConformedValue = previousConformedValue;
                }
                else if (isString(pipeResults)) {
                    pipeResults = { value: pipeResults };
                    finalConformedValue = pipeResults;
                }
            }
            // After determining the conformed value, we will need to know where to set
            // the caret position. `adjustCaretPosition` will tell us.
            const adjustedCaretPosition = adjustCaretPosition({
                previousConformedValue,
                previousPlaceholder,
                conformedValue: finalConformedValue,
                placeholder,
                rawValue: safeRawValue,
                currentCaretPosition: currentCaretPosition || 0,
                placeholderChar,
                indexesOfPipedChars: pipeResults.indexesOfPipedChars,
                caretTrapIndexes
            });
            // Text Mask sets the input value to an empty string when the condition below is set. It provides a better UX.
            const inputValueShouldBeEmpty = finalConformedValue === placeholder
                && (adjustedCaretPosition === 0 || adjustedCaretPosition === placeholder.length - 1);
            const emptyValue = showMask ? placeholder : '';
            const inputElementValue = (inputValueShouldBeEmpty) ? emptyValue : finalConformedValue;
            state.previousConformedValue = inputElementValue; // store value for access for next time
            state.previousPlaceholder = placeholder;
            // In some cases, this `update` method will be repeatedly called with a raw value that has already been conformed
            // and set to `inputElement.value`. The below check guards against needlessly readjusting the input state.
            // See https://github.com/text-mask/text-mask/issues/231
            if (inputElement.value === inputElementValue) {
                return;
            }
            inputElement.value = inputElementValue; // set the input value
            safeSetSelection(inputElement, adjustedCaretPosition); // adjust caret position
        }
    };
}
function safeSetSelection(element, selectionPosition) {
    if (document.activeElement === element && isNumber(selectionPosition)) {
        if (isAndroid) {
            defer(() => element.setSelectionRange(selectionPosition, selectionPosition, 'none'));
        }
        else {
            element.setSelectionRange(selectionPosition, selectionPosition, 'none');
        }
    }
}
function getSafeRawValue(inputValue) {
    if (isString(inputValue)) {
        return inputValue;
    }
    else if (isNumber(inputValue)) {
        return String(inputValue);
    }
    else if (inputValue === undefined || inputValue === null) {
        return '';
    }
    else {
        throw new Error('The \'value\' provided to Text Mask needs to be a string or a number. The value ' +
            `received was:\n\n ${JSON.stringify(inputValue)}`);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JlYXRlVGV4dE1hc2tJbnB1dEVsZW1lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL2NvcmUvY3JlYXRlVGV4dE1hc2tJbnB1dEVsZW1lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDNUQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ2hELE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLGlCQUFpQixFQUFXLFlBQVksRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUNySCxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFHckQsTUFBTSxTQUFTLEdBQUcsT0FBTyxTQUFTLEtBQUssV0FBVyxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQzNGLE1BQU0sS0FBSyxHQUFHLE9BQU8scUJBQXFCLEtBQUssV0FBVyxDQUFDLENBQUMsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDO0FBRWhHLE1BQU0sVUFBVSwwQkFBMEIsQ0FBQyxNQUFtQjtJQUM1RCxtR0FBbUc7SUFDbkcsTUFBTSxLQUFLLEdBQWtCO1FBQzNCLHNCQUFzQixFQUFFLFNBQVM7UUFDakMsbUJBQW1CLEVBQUUsU0FBUztLQUMvQixDQUFDO0lBRUYsT0FBTztRQUNMLEtBQUs7UUFFTCw0R0FBNEc7UUFDNUcsK0dBQStHO1FBQy9HLDJEQUEyRDtRQUMzRCxNQUFNLENBQUMsUUFBYSxFQUFFLEVBQ3BCLFlBQVksRUFDWixJQUFJLEVBQUUsWUFBWSxFQUNsQixLQUFLLEVBQ0wsSUFBSSxFQUNKLGVBQWUsR0FBRyxzQkFBc0IsRUFDeEMsaUJBQWlCLEdBQUcsS0FBSyxFQUN6QixRQUFRLEdBQUcsS0FBSyxFQUNqQixHQUFHLE1BQU07WUFD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QU0sSUFBSSxVQUFVLEtBQUssU0FBUyxJQUFJLFVBQVUsS0FBSyxJQUFJLEVBQUUsQ0FBQztRQUMzRCxPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUM7U0FBTSxDQUFDO1FBQ04sTUFBTSxJQUFJLEtBQUssQ0FDYixrRkFBa0Y7WUFDbEYscUJBQXFCLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FDbEQsQ0FBQztJQUNKLENBQUM7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYWRqdXN0Q2FyZXRQb3NpdGlvbiB9IGZyb20gJy4vYWRqdXN0Q2FyZXRQb3NpdGlvbic7XG5pbXBvcnQgeyBjb25mb3JtVG9NYXNrIH0gZnJvbSAnLi9jb25mb3JtVG9NYXNrJztcbmltcG9ydCB7IGNvbnZlcnRNYXNrVG9QbGFjZWhvbGRlciwgaXNTdHJpbmcsIGlzTnVtYmVyLCBwcm9jZXNzQ2FyZXRUcmFwcywgaXNBcnJheSwgaXNNYXNrT2JqZWN0IH0gZnJvbSAnLi91dGlsaXRpZXMnO1xuaW1wb3J0IHsgZGVmYXVsdFBsYWNlaG9sZGVyQ2hhciB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IENvbmZvcm1Db25maWcsIE1hc2ssIE1hc2tDb25maWcsIFRleHRNYXNrU3RhdGUgfSBmcm9tICcuL3R5cGluZ3MnO1xuXG5jb25zdCBpc0FuZHJvaWQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBkZWZlciA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09ICd1bmRlZmluZWQnID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogc2V0VGltZW91dDtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRleHRNYXNrSW5wdXRFbGVtZW50KGNvbmZpZz86IE1hc2tDb25maWcpOiBhbnkge1xuICAvLyBBbnl0aGluZyB0aGF0IHdlIHdpbGwgbmVlZCB0byBrZWVwIGJldHdlZW4gYHVwZGF0ZWAgY2FsbHMsIHdlIHdpbGwgc3RvcmUgaW4gdGhpcyBgc3RhdGVgIG9iamVjdC5cbiAgY29uc3Qgc3RhdGU6IFRleHRNYXNrU3RhdGUgPSB7XG4gICAgcHJldmlvdXNDb25mb3JtZWRWYWx1ZTogdW5kZWZpbmVkLFxuICAgIHByZXZpb3VzUGxhY2Vob2xkZXI6IHVuZGVmaW5lZFxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgc3RhdGUsXG5cbiAgICAvLyBgdXBkYXRlYCBpcyBjYWxsZWQgYnkgZnJhbWV3b3JrIGNvbXBvbmVudHMgd2hlbmV2ZXIgdGhleSB3YW50IHRvIHVwZGF0ZSB0aGUgYHZhbHVlYCBvZiB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICAvLyBUaGUgY2FsbGVyIGNhbiBzZW5kIGEgYHJhd1ZhbHVlYCB0byBiZSBjb25mb3JtZWQgYW5kIHNldCBvbiB0aGUgaW5wdXQgZWxlbWVudC4gSG93ZXZlciwgdGhlIGRlZmF1bHQgdXNlLWNhc2VcbiAgICAvLyBpcyBmb3IgdGhpcyB0byBiZSByZWFkIGZyb20gdGhlIGBpbnB1dEVsZW1lbnRgIGRpcmVjdGx5LlxuICAgIHVwZGF0ZShyYXdWYWx1ZTogYW55LCB7XG4gICAgICBpbnB1dEVsZW1lbnQsXG4gICAgICBtYXNrOiBwcm92aWRlZE1hc2ssXG4gICAgICBndWlkZSxcbiAgICAgIHBpcGUsXG4gICAgICBwbGFjZWhvbGRlckNoYXIgPSBkZWZhdWx0UGxhY2Vob2xkZXJDaGFyLFxuICAgICAga2VlcENoYXJQb3NpdGlvbnMgPSBmYWxzZSxcbiAgICAgIHNob3dNYXNrID0gZmFsc2VcbiAgICB9ID0gY29uZmlnKTogdm9pZCB7XG4gICAgICAvLyBpZiBgcmF3VmFsdWVgIGlzIGB1bmRlZmluZWRgLCByZWFkIGZyb20gdGhlIGBpbnB1dEVsZW1lbnRgXG4gICAgICBpZiAodHlwZW9mIHJhd1ZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByYXdWYWx1ZSA9IGlucHV0RWxlbWVudC52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYHJhd1ZhbHVlYCBlcXVhbHMgYHN0YXRlLnByZXZpb3VzQ29uZm9ybWVkVmFsdWVgLCB3ZSBkb24ndCBuZWVkIHRvIGNoYW5nZSBhbnl0aGluZy4gU28sIHdlIHJldHVybi5cbiAgICAgIC8vIFRoaXMgY2hlY2sgaXMgaGVyZSB0byBoYW5kbGUgY29udHJvbGxlZCBmcmFtZXdvcmsgY29tcG9uZW50cyB0aGF0IHJlcGVhdCB0aGUgYHVwZGF0ZWAgY2FsbCBvbiBldmVyeSByZW5kZXIuXG4gICAgICBpZiAocmF3VmFsdWUgPT09IHN0YXRlLnByZXZpb3VzQ29uZm9ybWVkVmFsdWUpIHsgcmV0dXJuOyB9XG5cbiAgICAgIC8vIFdlIGRvbid0IGtub3cgd2hhdCB0aGUgbWFzayB3b3VsZCBiZSB5ZXQuIElmIGl0IGlzIGFuIGFycmF5LCB3ZSB0YWtlIGl0IGFzIGlzLCBidXQgaWYgaXQncyBhIGZ1bmN0aW9uLCB3ZSB3aWxsXG4gICAgICAvLyBoYXZlIHRvIGNhbGwgdGhhdCBmdW5jdGlvbiB0byBnZXQgdGhlIG1hc2sgYXJyYXkuXG4gICAgICBsZXQgbWFzazogTWFzaztcblxuICAgICAgLy8gVGV4dCBNYXNrIGFjY2VwdHMgbWFza3MgdGhhdCBhcmUgYSBjb21iaW5hdGlvbiBvZiBhIGBtYXNrYCBhbmQgYSBgcGlwZWAgdGhhdCB3b3JrIHRvZ2V0aGVyLiBJZiBzdWNoIGEgYG1hc2tgIGlzXG4gICAgICAvLyBwYXNzZWQsIHdlIGRlc3RydWN0dXJlIGl0IGJlbG93LCBzbyB0aGUgcmVzdCBvZiB0aGUgY29kZSBjYW4gd29yayBub3JtYWxseSBhcyBpZiBhIHNlcGFyYXRlIGBtYXNrYCBhbmQgYSBgcGlwZWBcbiAgICAgIC8vIHdlcmUgcGFzc2VkLlxuICAgICAgaWYgKGlzTWFza09iamVjdChwcm92aWRlZE1hc2spKSB7XG4gICAgICAgIHBpcGUgPSBwcm92aWRlZE1hc2sucGlwZTtcbiAgICAgICAgcHJvdmlkZWRNYXNrID0gcHJvdmlkZWRNYXNrLm1hc2s7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBgcGxhY2Vob2xkZXJgIGlzIGFuIGVzc2VudGlhbCBwaWVjZSBvZiBob3cgVGV4dCBNYXNrIHdvcmtzLiBGb3IgYSBtYXNrIGxpa2UgYCgxMTEpYCwgdGhlIHBsYWNlaG9sZGVyIHdvdWxkXG4gICAgICAvLyBiZSBgKF9fXylgIGlmIHRoZSBgcGxhY2Vob2xkZXJDaGFyYCBpcyBzZXQgdG8gYF9gLlxuICAgICAgbGV0IHBsYWNlaG9sZGVyID0gJyc7XG5cbiAgICAgIC8vIElmIHRoZSBwcm92aWRlZCBtYXNrIGlzIGFuIGFycmF5LCB3ZSBjYW4gY2FsbCBgY29udmVydE1hc2tUb1BsYWNlaG9sZGVyYCBoZXJlIG9uY2UgYW5kIHdlJ2xsIGFsd2F5cyBoYXZlIHRoZVxuICAgICAgLy8gY29ycmVjdCBgcGxhY2Vob2xkZXJgLlxuICAgICAgaWYgKHByb3ZpZGVkTWFzayBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHBsYWNlaG9sZGVyID0gY29udmVydE1hc2tUb1BsYWNlaG9sZGVyKHByb3ZpZGVkTWFzaywgcGxhY2Vob2xkZXJDaGFyKTtcbiAgICAgIH1cblxuICAgICAgLy8gSW4gZnJhbWV3b3JrIGNvbXBvbmVudHMgdGhhdCBzdXBwb3J0IHJlYWN0aXZpdHksIGl0J3MgcG9zc2libGUgdG8gdHVybiBvZmYgbWFza2luZyBieSBwYXNzaW5nXG4gICAgICAvLyBgZmFsc2VgIGZvciBgbWFza2AgYWZ0ZXIgaW5pdGlhbGl6YXRpb24uIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdGV4dC1tYXNrL3RleHQtbWFzay9wdWxsLzM1OVxuICAgICAgaWYgKCFwcm92aWRlZE1hc2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBjaGVjayB0aGUgcHJvdmlkZWQgYHJhd1ZhbHVlYCBiZWZvcmUgbW92aW5nIGZ1cnRoZXIuXG4gICAgICAvLyBJZiBpdCdzIHNvbWV0aGluZyB3ZSBjYW4ndCB3b3JrIHdpdGggYGdldFNhZmVSYXdWYWx1ZWAgd2lsbCB0aHJvdy5cbiAgICAgIGNvbnN0IHNhZmVSYXdWYWx1ZSA9IGdldFNhZmVSYXdWYWx1ZShyYXdWYWx1ZSk7XG5cbiAgICAgIC8vIGBzZWxlY3Rpb25FbmRgIGluZGljYXRlcyB0byB1cyB3aGVyZSB0aGUgY2FyZXQgcG9zaXRpb24gaXMgYWZ0ZXIgdGhlIHVzZXIgaGFzIHR5cGVkIGludG8gdGhlIGlucHV0XG4gICAgICBjb25zdCB7IHNlbGVjdGlvbkVuZDogY3VycmVudENhcmV0UG9zaXRpb24gfSA9IGlucHV0RWxlbWVudDtcblxuICAgICAgLy8gV2UgbmVlZCB0byBrbm93IHdoYXQgdGhlIGBwcmV2aW91c0NvbmZvcm1lZFZhbHVlYCBhbmQgYHByZXZpb3VzUGxhY2Vob2xkZXJgIGlzIGZyb20gdGhlIHByZXZpb3VzIGB1cGRhdGVgIGNhbGxcbiAgICAgIGNvbnN0IHsgcHJldmlvdXNDb25mb3JtZWRWYWx1ZSwgcHJldmlvdXNQbGFjZWhvbGRlciB9ID0gc3RhdGU7XG5cbiAgICAgIGxldCBjYXJldFRyYXBJbmRleGVzOiBudW1iZXJbXSA9IFtdO1xuXG4gICAgICAvLyBJZiB0aGUgYHByb3ZpZGVkTWFza2AgaXMgYSBmdW5jdGlvbi4gV2UgbmVlZCB0byBjYWxsIGl0IGF0IGV2ZXJ5IGB1cGRhdGVgIHRvIGdldCB0aGUgYG1hc2tgIGFycmF5LlxuICAgICAgLy8gVGhlbiB3ZSBhbHNvIG5lZWQgdG8gZ2V0IHRoZSBgcGxhY2Vob2xkZXJgXG4gICAgICBpZiAodHlwZW9mIHByb3ZpZGVkTWFzayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtYXNrID0gcHJvdmlkZWRNYXNrKHNhZmVSYXdWYWx1ZSwgeyBjdXJyZW50Q2FyZXRQb3NpdGlvbiwgcHJldmlvdXNDb25mb3JtZWRWYWx1ZSwgcGxhY2Vob2xkZXJDaGFyIH0pO1xuXG4gICAgICAgIC8vIGRpc2FibGUgbWFza2luZyBpZiBgbWFza2AgaXMgYGZhbHNlYFxuICAgICAgICBpZiAoIW1hc2spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYXNrIGZ1bmN0aW9ucyBjYW4gc2V0dXAgY2FyZXQgdHJhcHMgdG8gaGF2ZSBzb21lIGNvbnRyb2wgb3ZlciBob3cgdGhlIGNhcmV0IG1vdmVzLiBXZSBuZWVkIHRvIHByb2Nlc3NcbiAgICAgICAgLy8gdGhlIG1hc2sgZm9yIGFueSBjYXJldCB0cmFwcy4gYHByb2Nlc3NDYXJldFRyYXBzYCB3aWxsIHJlbW92ZSB0aGUgY2FyZXQgdHJhcHMgZnJvbSB0aGUgbWFzayBhbmQgcmV0dXJuXG4gICAgICAgIC8vIHRoZSBpbmRleGVzIG9mIHRoZSBjYXJldCB0cmFwcy5cbiAgICAgICAgY2FyZXRUcmFwSW5kZXhlcyA9IHByb2Nlc3NDYXJldFRyYXBzKG1hc2spO1xuXG4gICAgICAgIHBsYWNlaG9sZGVyID0gY29udmVydE1hc2tUb1BsYWNlaG9sZGVyKG1hc2ssIHBsYWNlaG9sZGVyQ2hhcik7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHRoZSBgcHJvdmlkZWRNYXNrYCBpcyBub3QgYSBmdW5jdGlvbiwgd2UganVzdCB1c2UgaXQgYXMtaXMuXG4gICAgICAgIG1hc2sgPSBwcm92aWRlZE1hc2s7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIHRvIGBjb25mb3JtVG9NYXNrYCB0byBkZXRlcm1pbmUgaG93IHRoZSBgcmF3VmFsdWVgIHdpbGwgYmUgY29uZm9ybWVkXG4gICAgICBjb25zdCBjb25mb3JtVG9NYXNrQ29uZmlnOiBDb25mb3JtQ29uZmlnID0ge1xuICAgICAgICBwcmV2aW91c0NvbmZvcm1lZFZhbHVlLFxuICAgICAgICBndWlkZSxcbiAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgIHBsYWNlaG9sZGVyQ2hhcixcbiAgICAgICAgcGlwZSxcbiAgICAgICAgY3VycmVudENhcmV0UG9zaXRpb24sXG4gICAgICAgIGtlZXBDaGFyUG9zaXRpb25zXG4gICAgICB9O1xuXG4gICAgICAvLyBgY29uZm9ybVRvTWFza2AgcmV0dXJucyBgY29uZm9ybWVkVmFsdWVgIGFzIHBhcnQgb2YgYW4gb2JqZWN0IGZvciBmdXR1cmUgQVBJIGZsZXhpYmlsaXR5XG4gICAgICBjb25zdCB7IGNvbmZvcm1lZFZhbHVlIH0gPSBjb25mb3JtVG9NYXNrKHNhZmVSYXdWYWx1ZSwgbWFzaywgY29uZm9ybVRvTWFza0NvbmZpZyk7XG5cbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgZmV3IGxpbmVzIGFyZSB0byBzdXBwb3J0IHRoZSBgcGlwZWAgZmVhdHVyZS5cbiAgICAgIGxldCBwaXBlUmVzdWx0czogYW55ID0ge307XG5cbiAgICAgIC8vIHdlIG5lZWQgdG8ga25vdyB3aGljaCBjb25mb3JtZWQgdmFsdWUgdG8gdXNlLCB0aGUgb25lIHJldHVybmVkIGJ5IHRoZSBwaXBlIG9yIHRoZSBvbmVcbiAgICAgIC8vIHJldHVybmVkIGJ5IGBjb25mb3JtVG9NYXNrYC5cbiAgICAgIGxldCBmaW5hbENvbmZvcm1lZFZhbHVlOiBhbnkgPSBjb25mb3JtZWRWYWx1ZTtcblxuICAgICAgLy8gSWYgYHBpcGVgIGlzIGEgZnVuY3Rpb24sIHdlIGNhbGwgaXQuXG4gICAgICBpZiAodHlwZW9mIHBpcGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gYHBpcGVgIHJlY2VpdmVzIHRoZSBgY29uZm9ybWVkVmFsdWVgIGFuZCB0aGUgY29uZmlndXJhdGlvbnMgd2l0aCB3aGljaCBgY29uZm9ybVRvTWFza2Agd2FzIGNhbGxlZC5cbiAgICAgICAgcGlwZVJlc3VsdHMgPSBwaXBlKGNvbmZvcm1lZFZhbHVlLCB7IHJhd1ZhbHVlOiBzYWZlUmF3VmFsdWUsIC4uLmNvbmZvcm1Ub01hc2tDb25maWd9KTtcblxuICAgICAgICAvLyBgcGlwZVJlc3VsdHNgIHNob3VsZCBiZSBhbiBvYmplY3QuIEJ1dCBhcyBhIGNvbnZlbmllbmNlLCB3ZSBhbGxvdyB0aGUgcGlwZSBhdXRob3IgdG8ganVzdCByZXR1cm4gYGZhbHNlYCB0b1xuICAgICAgICAvLyBpbmRpY2F0ZSByZWplY3Rpb24uIE9yIHJldHVybiBqdXN0IGEgc3RyaW5nIHdoZW4gdGhlcmUgYXJlIG5vIHBpcGVkIGNoYXJhY3RlcnMuXG4gICAgICAgIC8vIElmIHRoZSBgcGlwZWAgcmV0dXJucyBgZmFsc2VgIG9yIGEgc3RyaW5nLCB0aGUgYmxvY2sgYmVsb3cgdHVybnMgaXQgaW50byBhbiBvYmplY3QgdGhhdCB0aGUgcmVzdFxuICAgICAgICAvLyBvZiB0aGUgY29kZSBjYW4gd29yayB3aXRoLlxuICAgICAgICBpZiAocGlwZVJlc3VsdHMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGBwaXBlYCByZWplY3RzIGBjb25mb3JtZWRWYWx1ZWAsIHdlIHVzZSB0aGUgYHByZXZpb3VzQ29uZm9ybWVkVmFsdWVgLCBhbmQgc2V0IGByZWplY3RlZGAgdG8gYHRydWVgLlxuICAgICAgICAgIHBpcGVSZXN1bHRzID0ge3ZhbHVlOiBwcmV2aW91c0NvbmZvcm1lZFZhbHVlLCByZWplY3RlZDogdHJ1ZX07XG4gICAgICAgICAgZmluYWxDb25mb3JtZWRWYWx1ZSA9IHByZXZpb3VzQ29uZm9ybWVkVmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcocGlwZVJlc3VsdHMpKSB7XG4gICAgICAgICAgcGlwZVJlc3VsdHMgPSB7dmFsdWU6IHBpcGVSZXN1bHRzfTtcbiAgICAgICAgICBmaW5hbENvbmZvcm1lZFZhbHVlID0gcGlwZVJlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWZ0ZXIgZGV0ZXJtaW5pbmcgdGhlIGNvbmZvcm1lZCB2YWx1ZSwgd2Ugd2lsbCBuZWVkIHRvIGtub3cgd2hlcmUgdG8gc2V0XG4gICAgICAvLyB0aGUgY2FyZXQgcG9zaXRpb24uIGBhZGp1c3RDYXJldFBvc2l0aW9uYCB3aWxsIHRlbGwgdXMuXG4gICAgICBjb25zdCBhZGp1c3RlZENhcmV0UG9zaXRpb24gPSBhZGp1c3RDYXJldFBvc2l0aW9uKHtcbiAgICAgICAgcHJldmlvdXNDb25mb3JtZWRWYWx1ZSxcbiAgICAgICAgcHJldmlvdXNQbGFjZWhvbGRlcixcbiAgICAgICAgY29uZm9ybWVkVmFsdWU6IGZpbmFsQ29uZm9ybWVkVmFsdWUsXG4gICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICByYXdWYWx1ZTogc2FmZVJhd1ZhbHVlLFxuICAgICAgICBjdXJyZW50Q2FyZXRQb3NpdGlvbjogY3VycmVudENhcmV0UG9zaXRpb24gfHwgMCxcbiAgICAgICAgcGxhY2Vob2xkZXJDaGFyLFxuICAgICAgICBpbmRleGVzT2ZQaXBlZENoYXJzOiBwaXBlUmVzdWx0cy5pbmRleGVzT2ZQaXBlZENoYXJzLFxuICAgICAgICBjYXJldFRyYXBJbmRleGVzXG4gICAgICB9KTtcblxuICAgICAgLy8gVGV4dCBNYXNrIHNldHMgdGhlIGlucHV0IHZhbHVlIHRvIGFuIGVtcHR5IHN0cmluZyB3aGVuIHRoZSBjb25kaXRpb24gYmVsb3cgaXMgc2V0LiBJdCBwcm92aWRlcyBhIGJldHRlciBVWC5cbiAgICAgIGNvbnN0IGlucHV0VmFsdWVTaG91bGRCZUVtcHR5ID0gZmluYWxDb25mb3JtZWRWYWx1ZSA9PT0gcGxhY2Vob2xkZXJcbiAgICAgICAgJiYgKGFkanVzdGVkQ2FyZXRQb3NpdGlvbiA9PT0gMCB8fCBhZGp1c3RlZENhcmV0UG9zaXRpb24gPT09IHBsYWNlaG9sZGVyLmxlbmd0aCAtIDEpO1xuICAgICAgY29uc3QgZW1wdHlWYWx1ZSA9IHNob3dNYXNrID8gcGxhY2Vob2xkZXIgOiAnJztcbiAgICAgIGNvbnN0IGlucHV0RWxlbWVudFZhbHVlID0gKGlucHV0VmFsdWVTaG91bGRCZUVtcHR5KSA/IGVtcHR5VmFsdWUgOiBmaW5hbENvbmZvcm1lZFZhbHVlO1xuXG4gICAgICBzdGF0ZS5wcmV2aW91c0NvbmZvcm1lZFZhbHVlID0gaW5wdXRFbGVtZW50VmFsdWU7IC8vIHN0b3JlIHZhbHVlIGZvciBhY2Nlc3MgZm9yIG5leHQgdGltZVxuICAgICAgc3RhdGUucHJldmlvdXNQbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuXG4gICAgICAvLyBJbiBzb21lIGNhc2VzLCB0aGlzIGB1cGRhdGVgIG1ldGhvZCB3aWxsIGJlIHJlcGVhdGVkbHkgY2FsbGVkIHdpdGggYSByYXcgdmFsdWUgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGNvbmZvcm1lZFxuICAgICAgLy8gYW5kIHNldCB0byBgaW5wdXRFbGVtZW50LnZhbHVlYC4gVGhlIGJlbG93IGNoZWNrIGd1YXJkcyBhZ2FpbnN0IG5lZWRsZXNzbHkgcmVhZGp1c3RpbmcgdGhlIGlucHV0IHN0YXRlLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90ZXh0LW1hc2svdGV4dC1tYXNrL2lzc3Vlcy8yMzFcbiAgICAgIGlmIChpbnB1dEVsZW1lbnQudmFsdWUgPT09IGlucHV0RWxlbWVudFZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaW5wdXRFbGVtZW50LnZhbHVlID0gaW5wdXRFbGVtZW50VmFsdWU7IC8vIHNldCB0aGUgaW5wdXQgdmFsdWVcbiAgICAgIHNhZmVTZXRTZWxlY3Rpb24oaW5wdXRFbGVtZW50LCBhZGp1c3RlZENhcmV0UG9zaXRpb24pOyAvLyBhZGp1c3QgY2FyZXQgcG9zaXRpb25cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNhZmVTZXRTZWxlY3Rpb24oZWxlbWVudDogSFRNTElucHV0RWxlbWVudCwgc2VsZWN0aW9uUG9zaXRpb24/OiBudW1iZXIgfCB2b2lkKTogdm9pZCB7XG4gIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbGVtZW50ICYmIGlzTnVtYmVyKHNlbGVjdGlvblBvc2l0aW9uKSkge1xuICAgIGlmIChpc0FuZHJvaWQpIHtcbiAgICAgIGRlZmVyKCgpID0+IGVsZW1lbnQuc2V0U2VsZWN0aW9uUmFuZ2Uoc2VsZWN0aW9uUG9zaXRpb24sIHNlbGVjdGlvblBvc2l0aW9uLCAnbm9uZScpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZShzZWxlY3Rpb25Qb3NpdGlvbiwgc2VsZWN0aW9uUG9zaXRpb24sICdub25lJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNhZmVSYXdWYWx1ZShpbnB1dFZhbHVlOiBhbnkpOiBzdHJpbmcge1xuICBpZiAoaXNTdHJpbmcoaW5wdXRWYWx1ZSkpIHtcbiAgICByZXR1cm4gaW5wdXRWYWx1ZTtcbiAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dFZhbHVlKSkge1xuICAgIHJldHVybiBTdHJpbmcoaW5wdXRWYWx1ZSk7XG4gIH0gZWxzZSBpZiAoaW5wdXRWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGlucHV0VmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1RoZSBcXCd2YWx1ZVxcJyBwcm92aWRlZCB0byBUZXh0IE1hc2sgbmVlZHMgdG8gYmUgYSBzdHJpbmcgb3IgYSBudW1iZXIuIFRoZSB2YWx1ZSAnICtcbiAgICAgIGByZWNlaXZlZCB3YXM6XFxuXFxuICR7SlNPTi5zdHJpbmdpZnkoaW5wdXRWYWx1ZSl9YFxuICAgICk7XG4gIH1cbn1cbiJdfQ==