{"version":3,"file":"matheo-text-mask.mjs","sources":["../../src/lib/core/typings.ts","../../src/lib/core/constants.ts","../../src/lib/core/utilities.ts","../../src/lib/core/conformToMask.ts","../../src/lib/core/adjustCaretPosition.ts","../../src/lib/core/createTextMaskInputElement.ts","../../src/lib/text-mask.ts","../../src/lib/matheo-text-mask.ts"],"sourcesContent":["export interface ConformConfig {\n  previousConformedValue?: string;\n  guide?: boolean;\n  placeholder?: string;\n  placeholderChar: string;\n  pipe?: ProvidedPipe;\n  currentCaretPosition: number | null;\n  keepCharPositions: boolean;\n  rawValue?: string;\n}\n\nexport interface ConformResponse {\n  conformedValue: string;\n  meta: {\n    someCharsRejected: boolean;\n  };\n}\n\nexport interface CaretConfig {\n  previousConformedValue?: string;\n  previousPlaceholder?: string;\n  guide?: boolean;\n  currentCaretPosition: number;\n  conformedValue: string;\n  rawValue: string;\n  placeholderChar: string;\n  placeholder: string;\n  indexesOfPipedChars?: number[];\n  caretTrapIndexes?: number[];\n}\n\nexport interface TextMaskState {\n  previousConformedValue?: string;\n  previousPlaceholder?: string;\n}\n\nexport interface MaskParams {\n  currentCaretPosition?: number | null;\n  previousConformedValue?: string;\n  placeholderChar?: string;\n}\n\nexport type MaskCreator = (raw: string, params: MaskParams) => Mask;\n\nexport type Mask = Array<string | RegExp>;\n\nexport type ProvidedPipe = (conformedValue: string, config: ConformConfig) => false | string | object;\n\nexport interface MaskObject {\n  mask: Mask;\n  pipe: ProvidedPipe;\n}\n\nexport class TextMaskConfig {\n  mask?: Mask | MaskCreator | MaskObject | false;\n  guide?: boolean;\n  placeholderChar?: string;\n  pipe?: ProvidedPipe;\n  keepCharPositions?: boolean;\n  showMask?: boolean;\n}\n\nexport interface MaskConfig extends TextMaskConfig {\n  inputElement: HTMLInputElement;\n}\n","export const defaultPlaceholderChar = '_';\n","import { defaultPlaceholderChar } from './constants';\nimport { Mask, MaskCreator, MaskObject } from './typings';\n\nexport const err = 'text-mask: convertMaskToPlaceholder; The mask property must be an array.';\n\nexport function convertMaskToPlaceholder(\n  mask: Mask,\n  placeholderChar = defaultPlaceholderChar\n): string {\n  if (!isArray(mask)) {\n    throw new Error(err);\n  }\n\n  if (mask.indexOf(placeholderChar) !== -1) {\n    throw new Error(\n      'Placeholder character must not be used as part of the mask. Please specify a character ' +\n      'that is not present in your mask as your placeholder character.\\n\\n' +\n      `The placeholder character that was received is: ${JSON.stringify(placeholderChar)}\\n\\n` +\n      `The mask that was received is: ${JSON.stringify(mask)}`\n    );\n  }\n\n  return mask.map((char) => {\n    return (char instanceof RegExp) ? placeholderChar : char;\n  }).join('');\n}\n\nexport function isMaskCreator(value: any): value is MaskCreator {\n  return typeof value === 'function';\n}\n\nexport function isMaskObject(value: any): value is MaskObject {\n  return typeof value === 'object' && value.pipe !== undefined && value.mask !== undefined;\n}\n\nexport function isArray<T>(value: any): value is Array<T> {\n  return (Array.isArray && Array.isArray(value)) || value instanceof Array;\n}\n\nexport function isString(value: any): value is string {\n  return typeof value === 'string' || value instanceof String;\n}\n\nexport function isNumber(value: any): value is number {\n  return typeof value === 'number' && !isNaN(value);\n}\n\nexport function isNil(value: any): value is null {\n  return typeof value === 'undefined' || value === null;\n}\n\nexport function processCaretTraps(mask: Mask): number[] {\n  const caretTrapIndexes: number[] = [];\n  let indexOfCaretTrap: number = mask?.indexOf('[]');\n\n  while (mask && indexOfCaretTrap !== -1) {\n    caretTrapIndexes.push(indexOfCaretTrap);\n    mask.splice(indexOfCaretTrap, 1);\n    indexOfCaretTrap = mask.indexOf('[]');\n  }\n\n  return caretTrapIndexes;\n}\n","import {convertMaskToPlaceholder, isArray, isMaskCreator, processCaretTraps} from './utilities';\nimport {defaultPlaceholderChar} from './constants';\nimport { Mask, ConformConfig, MaskCreator, ConformResponse } from './typings';\n\nexport const err = 'Text-mask:conformToMask; The mask property must be an array.';\n\nexport function conformToMask(\n  rawValue = '',\n  mask: Mask | MaskCreator = [],\n  config: Partial<ConformConfig> = {}\n): ConformResponse {\n  if (!isArray(mask)) {\n    // If someone passes a function as the mask property, we should call the\n    // function to get the mask array - Normally this is handled by the\n    // `createTextMaskInputElement:update` function - this allows mask functions\n    // to be used directly with `conformToMask`\n    if (isMaskCreator(mask)) {\n      // call the mask function to get the mask array\n      mask = mask(rawValue, config);\n\n      // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n      // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask\n      processCaretTraps(mask);\n    } else {\n      throw new Error(err);\n    }\n  }\n\n  // These configurations tell us how to conform the mask\n  const {\n    guide = true,\n    previousConformedValue = '',\n    placeholderChar = defaultPlaceholderChar,\n    placeholder = convertMaskToPlaceholder(mask, placeholderChar),\n    currentCaretPosition,\n    keepCharPositions\n  } = config;\n\n  // The configs below indicate that the user wants the algorithm to work in *no guide* mode\n  const suppressGuide = guide === false && previousConformedValue !== undefined;\n\n  // Calculate lengths once for performance\n  const rawValueLength = rawValue.length;\n  const previousConformedValueLength = previousConformedValue.length;\n  const placeholderLength = placeholder.length;\n  const maskLength = mask.length;\n\n  // This tells us the number of edited characters and the direction in which they were edited (+/-)\n  const editDistance = rawValueLength - previousConformedValueLength;\n\n  // In *no guide* mode, we need to know if the user is trying to add a character or not\n  const isAddition = editDistance > 0;\n\n  // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\n  const indexOfFirstChange = (currentCaretPosition || 0) + (isAddition ? -editDistance : 0);\n\n  // We're also gonna need the index of last change, which we can derive as follows...\n  const indexOfLastChange = indexOfFirstChange + Math.abs(editDistance);\n\n  // If `conformToMask` is configured to keep character positions, that is, for mask 111, previous value\n  // _2_ and raw value 3_2_, the new conformed value should be 32_, not 3_2 (default behavior). That's in the case of\n  // addition. And in the case of deletion, previous value _23, raw value _3, the new conformed string should be\n  // __3, not _3_ (default behavior)\n  //\n  // The next block of logic handles keeping character positions for the case of deletion. (Keeping\n  // character positions for the case of addition is further down since it is handled differently.)\n  // To do this, we want to compensate for all characters that were deleted\n  if (keepCharPositions === true && !isAddition) {\n    // We will be storing the new placeholder characters in this variable.\n    let compensatingPlaceholderChars = '';\n\n    // For every character that was deleted from a placeholder position, we add a placeholder char\n    for (let i = indexOfFirstChange; i < indexOfLastChange; i++) {\n      if (placeholder[i] === placeholderChar) {\n        compensatingPlaceholderChars += placeholderChar;\n      }\n    }\n\n    // Now we trick our algorithm by modifying the raw value to make it contain additional placeholder characters\n    // That way when the we start laying the characters again on the mask, it will keep the non-deleted characters\n    // in their positions.\n    rawValue = (\n      rawValue.slice(0, indexOfFirstChange) +\n      compensatingPlaceholderChars +\n      rawValue.slice(indexOfFirstChange, rawValueLength)\n    );\n  }\n\n  // Convert `rawValue` string to an array, and mark characters based on whether they are newly added or have\n  // existed in the previous conformed value. Identifying new and old characters is needed for `conformToMask`\n  // to work if it is configured to keep character positions.\n  const rawValueArr = rawValue\n    .split('')\n    .map((char, i) => ({char, isNew: i >= indexOfFirstChange && i < indexOfLastChange}));\n\n  // The loop below removes masking characters from user input. For example, for mask\n  // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below\n  // would remove all characters but `234` from the `rawValueArr`. The rest of the algorithm\n  // then would lay `234` on top of the available placeholder positions in the mask.\n  for (let i = rawValueLength - 1; i >= 0; i--) {\n    const {char} = rawValueArr[i];\n\n    if (char !== placeholderChar) {\n      const shouldOffset = i >= indexOfFirstChange && previousConformedValueLength === maskLength;\n\n      if (char === placeholder[(shouldOffset) ? i - editDistance : i]) {\n        rawValueArr.splice(i, 1);\n      }\n    }\n  }\n\n  // This is the variable that we will be filling with characters as we figure them out\n  // in the algorithm below\n  let conformedValue = '';\n  let someCharsRejected = false;\n\n  // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.\n  placeholderLoop: for (let i = 0; i < placeholderLength; i++) {\n    const charInPlaceholder = placeholder[i];\n\n    // We see one. Let's find out what we can put in it.\n    if (charInPlaceholder === placeholderChar) {\n      // But before that, do we actually have any user characters that need a place?\n      if (rawValueArr.length > 0) {\n        // We will keep chipping away at user input until either we run out of characters\n        // or we find at least one character that we can map.\n        while (rawValueArr.length > 0) {\n          // Let's retrieve the first user character in the queue of characters we have left\n          const res = rawValueArr.shift();\n\n          // If the character we got from the user input is a placeholder character (which happens\n          // regularly because user input could be something like (540) 90_-____, which includes\n          // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,\n          // then we map this placeholder character to the current spot in the placeholder\n          if (res?.char === placeholderChar && suppressGuide !== true) {\n            conformedValue += placeholderChar;\n\n            // And we go to find the next placeholder character that needs filling\n            continue placeholderLoop;\n\n          // Else if, the character we got from the user input is not a placeholder, let's see\n          // if the current position in the mask can accept it.\n          } else if (res?.char && (mask[i] as RegExp).test(res.char)) {\n            // we map the character differently based on whether we are keeping character positions or not.\n            // If any of the conditions below are met, we simply map the raw value character to the\n            // placeholder position.\n            if (\n              keepCharPositions !== true ||\n              res?.isNew === false ||\n              previousConformedValue === '' ||\n              guide === false ||\n              !isAddition\n            ) {\n              conformedValue += res?.char;\n            } else {\n              // We enter this block of code if we are trying to keep character positions and none of the conditions\n              // above is met. In this case, we need to see if there's an available spot for the raw value character\n              // to be mapped to. If we couldn't find a spot, we will discard the character.\n              //\n              // For example, for mask `1111`, previous conformed value `_2__`, raw value `942_2__`. We can map the\n              // `9`, to the first available placeholder position, but then, there are no more spots available for the\n              // `4` and `2`. So, we discard them and end up with a conformed value of `92__`.\n              const rawValueArrLength = rawValueArr.length;\n              let indexOfNextAvailablePlaceholderChar = null;\n\n              // Let's loop through the remaining raw value characters. We are looking for either a suitable spot, ie,\n              // a placeholder character or a non-suitable spot, ie, a non-placeholder character that is not new.\n              // If we see a suitable spot first, we store its position and exit the loop. If we see a non-suitable\n              // spot first, we exit the loop and our `indexOfNextAvailablePlaceholderChar` will stay as `null`.\n              for (let k = 0; k < rawValueArrLength; k++) {\n                const charData = rawValueArr[k];\n\n                if (charData.char !== placeholderChar && charData.isNew === false) {\n                  break;\n                }\n\n                if (charData.char === placeholderChar) {\n                  indexOfNextAvailablePlaceholderChar = k;\n                  break;\n                }\n              }\n\n              // If `indexOfNextAvailablePlaceholderChar` is not `null`, that means the character is not blocked.\n              // We can map it. And to keep the character positions, we remove the placeholder character\n              // from the remaining characters\n              if (indexOfNextAvailablePlaceholderChar !== null) {\n                conformedValue += res?.char;\n                rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1);\n\n              // If `indexOfNextAvailablePlaceholderChar` is `null`, that means the character is blocked. We have to\n              // discard it.\n              } else {\n                i--;\n              }\n            }\n\n            // Since we've mapped this placeholder position. We move on to the next one.\n            continue placeholderLoop;\n          } else {\n            someCharsRejected = true;\n          }\n        }\n      }\n\n      // We reach this point when we've mapped all the user input characters to placeholder\n      // positions in the mask. In *guide* mode, we append the left over characters in the\n      // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.\n      //\n      // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.\n      if (suppressGuide === false) {\n        conformedValue += placeholder.substr(i, placeholderLength);\n      }\n\n      // And we break\n      break;\n\n    // Else, the charInPlaceholder is not a placeholderChar. That is, we cannot fill it\n    // with user input. So we just map it to the final output\n    } else {\n      conformedValue += charInPlaceholder;\n    }\n  }\n\n  // The following logic is needed to deal with the case of deletion in *no guide* mode.\n  //\n  // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder\n  // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.\n  // That's why the logic below finds the last filled placeholder character, and removes everything\n  // from that point on.\n  if (suppressGuide && isAddition === false) {\n    let indexOfLastFilledPlaceholderChar = null;\n\n    // Find the last filled placeholder position and substring from there\n    for (let i = 0; i < conformedValue.length; i++) {\n      if (placeholder[i] === placeholderChar) {\n        indexOfLastFilledPlaceholderChar = i;\n      }\n    }\n\n    if (indexOfLastFilledPlaceholderChar !== null) {\n      // We substring from the beginning until the position after the last filled placeholder char.\n      conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1);\n    } else {\n      // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted\n      // the first character in the mask. So we return an empty string.\n      conformedValue = '';\n    }\n  }\n\n  return { conformedValue, meta: { someCharsRejected } };\n}\n","import { CaretConfig } from './typings';\n\nexport function adjustCaretPosition({\n  previousConformedValue = '',\n  previousPlaceholder = '',\n  currentCaretPosition = 0,\n  conformedValue,\n  rawValue,\n  placeholderChar,\n  placeholder,\n  indexesOfPipedChars = [],\n  caretTrapIndexes = []\n}: CaretConfig): void | number | undefined {\n  if (currentCaretPosition === 0 || !rawValue.length) { return 0; }\n\n  // Store lengths for faster performance?\n  const rawValueLength = rawValue.length;\n  const previousConformedValueLength = previousConformedValue.length;\n  const placeholderLength = placeholder.length;\n  const conformedValueLength = conformedValue.length;\n\n  // This tells us how long the edit is. If user modified input from `(2__)` to `(243__)`,\n  // we know the user in this instance pasted two characters\n  const editLength = rawValueLength - previousConformedValueLength;\n\n  // If the edit length is positive, that means the user is adding characters, not deleting.\n  const isAddition = editLength > 0;\n\n  // This is the first raw value the user entered that needs to be conformed to mask\n  const isFirstRawValue = previousConformedValueLength === 0;\n\n  // A partial multi-character edit happens when the user makes a partial selection in their\n  // input and edits that selection. That is going from `(123) 432-4348` to `() 432-4348` by\n  // selecting the first 3 digits and pressing backspace.\n  //\n  // Such cases can also happen when the user presses the backspace while holding down the ALT\n  // key.\n  const isPartialMultiCharEdit = editLength > 1 && !isAddition && !isFirstRawValue;\n\n  // This algorithm doesn't support all cases of multi-character edits, so we just return\n  // the current caret position.\n  //\n  // This works fine for most cases.\n  if (isPartialMultiCharEdit) { return currentCaretPosition; }\n\n  // For a mask like (111), if the `previousConformedValue` is (1__) and user attempts to enter\n  // `f` so the `rawValue` becomes (1f__), the new `conformedValue` would be (1__), which is the\n  // same as the original `previousConformedValue`. We handle this case differently for caret\n  // positioning.\n  const possiblyHasRejectedChar = isAddition && (\n    previousConformedValue === conformedValue ||\n    conformedValue === placeholder\n  );\n\n  let startingSearchIndex = 0;\n  let trackRightCharacter;\n  let targetChar = '';\n\n  if (possiblyHasRejectedChar) {\n    startingSearchIndex = currentCaretPosition - editLength;\n  } else {\n    // At this point in the algorithm, we want to know where the caret is right before the raw input\n    // has been conformed, and then see if we can find that same spot in the conformed input.\n    //\n    // We do that by seeing what character lies immediately before the caret, and then look for that\n    // same character in the conformed input and place the caret there.\n\n    // First, we need to normalize the inputs so that letter capitalization between raw input and\n    // conformed input wouldn't matter.\n    const normalizedConformedValue = conformedValue.toLowerCase();\n    const normalizedRawValue = rawValue.toLowerCase();\n\n    // Then we take all characters that come before where the caret currently is.\n    const leftHalfChars = normalizedRawValue.substr(0, currentCaretPosition).split('');\n\n    // Now we find all the characters in the left half that exist in the conformed input\n    // This step ensures that we don't look for a character that was filtered out or rejected by `conformToMask`.\n    const intersection = leftHalfChars.filter((char) => normalizedConformedValue.indexOf(char) !== -1);\n\n    // The last character in the intersection is the character we want to look for in the conformed\n    // value and the one we want to adjust the caret close to\n    targetChar = intersection[intersection.length - 1];\n\n    // Calculate the number of mask characters in the previous placeholder\n    // from the start of the string up to the place where the caret is\n    const previousLeftMaskChars = previousPlaceholder\n      .substr(0, intersection.length)\n      .split('')\n      .filter(char => char !== placeholderChar)\n      .length;\n\n    // Calculate the number of mask characters in the current placeholder\n    // from the start of the string up to the place where the caret is\n    const leftMaskChars = placeholder\n      .substr(0, intersection.length)\n      .split('')\n      .filter(char => char !== placeholderChar)\n      .length;\n\n    // Has the number of mask characters up to the caret changed?\n    const masklengthChanged = leftMaskChars !== previousLeftMaskChars;\n\n    // Detect if `targetChar` is a mask character and has moved to the left\n    const targetIsMaskMovingLeft = (\n      previousPlaceholder[intersection.length - 1] !== undefined &&\n      placeholder[intersection.length - 2] !== undefined &&\n      previousPlaceholder[intersection.length - 1] !== placeholderChar &&\n      previousPlaceholder[intersection.length - 1] !== placeholder[intersection.length - 1] &&\n      previousPlaceholder[intersection.length - 1] === placeholder[intersection.length - 2]\n    );\n\n    // If deleting and the `targetChar` `is a mask character and `masklengthChanged` is true\n    // or the mask is moving to the left, we can't use the selected `targetChar` any longer\n    // if we are not at the end of the string.\n    // In this case, change tracking strategy and track the character to the right of the caret.\n    if (\n      !isAddition &&\n      (masklengthChanged || targetIsMaskMovingLeft) &&\n      previousLeftMaskChars > 0 &&\n      placeholder.indexOf(targetChar) > -1 &&\n      rawValue[currentCaretPosition] !== undefined\n    ) {\n      trackRightCharacter = true;\n      targetChar = rawValue[currentCaretPosition];\n    }\n\n    // It is possible that `targetChar` will appear multiple times in the conformed value.\n    // We need to know not to select a character that looks like our target character from the placeholder or\n    // the piped characters, so we inspect the piped characters and the placeholder to see if they contain\n    // characters that match our target character.\n\n    // If the `conformedValue` got piped, we need to know which characters were piped in so that when we look for\n    // our `targetChar`, we don't select a piped char by mistake\n    const pipedChars = indexesOfPipedChars.map((index) => normalizedConformedValue[index]);\n\n    // We need to know how many times the `targetChar` occurs in the piped characters.\n    const countTargetCharInPipedChars = pipedChars.filter((char) => char === targetChar).length;\n\n    // We need to know how many times it occurs in the intersection\n    const countTargetCharInIntersection = intersection.filter((char) => char === targetChar).length;\n\n    // We need to know if the placeholder contains characters that look like\n    // our `targetChar`, so we don't select one of those by mistake.\n    const countTargetCharInPlaceholder = placeholder\n      .substr(0, placeholder.indexOf(placeholderChar))\n      .split('')\n      .filter((char, index) => (\n        // Check if `char` is the same as our `targetChar`, so we account for it\n        char === targetChar &&\n\n        // but also make sure that both the `rawValue` and placeholder don't have the same character at the same\n        // index because if they are equal, that means we are already counting those characters in\n        // `countTargetCharInIntersection`\n        rawValue[index] !== char\n      ))\n      .length;\n\n    // The number of times we need to see occurrences of the `targetChar` before we know it is the one we're looking\n    // for is:\n    const requiredNumberOfMatches = (\n      countTargetCharInPlaceholder +\n      countTargetCharInIntersection +\n      countTargetCharInPipedChars +\n      // The character to the right of the caret isn't included in `intersection`\n      // so add one if we are tracking the character to the right\n      (trackRightCharacter ? 1 : 0)\n    );\n\n    // Now we start looking for the location of the `targetChar`.\n    // We keep looping forward and store the index in every iteration. Once we have encountered\n    // enough occurrences of the target character, we break out of the loop\n    // If are searching for the second `1` in `1214`, `startingSearchIndex` will point at `4`.\n    let numberOfEncounteredMatches = 0;\n    for (let i = 0; i < conformedValueLength; i++) {\n      const conformedValueChar = normalizedConformedValue[i];\n\n      startingSearchIndex = i + 1;\n\n      if (conformedValueChar === targetChar) {\n        numberOfEncounteredMatches++;\n      }\n\n      if (numberOfEncounteredMatches >= requiredNumberOfMatches) {\n        break;\n      }\n    }\n  }\n\n  // At this point, if we simply return `startingSearchIndex` as the adjusted caret position,\n  // most cases would be handled. However, we want to fast forward or rewind the caret to the\n  // closest placeholder character if it happens to be in a non-editable spot. That's what the next\n  // logic is for.\n\n  // In case of addition, we fast forward.\n  if (isAddition) {\n    // We want to remember the last placeholder character encountered so that if the mask\n    // contains more characters after the last placeholder character, we don't forward the caret\n    // that far to the right. Instead, we stop it at the last encountered placeholder character.\n    let lastPlaceholderChar = startingSearchIndex;\n\n    for (let i = startingSearchIndex; i <= placeholderLength; i++) {\n      if (placeholder[i] === placeholderChar) {\n        lastPlaceholderChar = i;\n      }\n\n      if (\n        // If we're adding, we can position the caret at the next placeholder character.\n        placeholder[i] === placeholderChar ||\n\n        // If a caret trap was set by a mask function, we need to stop at the trap.\n        caretTrapIndexes.indexOf(i) !== -1 ||\n\n        // This is the end of the placeholder. We cannot move any further. Let's put the caret there.\n        i === placeholderLength\n      ) {\n        return lastPlaceholderChar;\n      }\n    }\n  } else {\n    // In case of deletion, we rewind.\n    if (trackRightCharacter) {\n      // Searching for the character that was to the right of the caret\n      // We start at `startingSearchIndex` - 1 because it includes one character extra to the right\n      for (let i = startingSearchIndex - 1; i >= 0; i--) {\n        // If tracking the character to the right of the cursor, we move to the left until\n        // we found the character and then place the caret right before it\n\n        if (\n          // `targetChar` should be in `conformedValue`, since it was in `rawValue`, just\n          // to the right of the caret\n          conformedValue[i] === targetChar ||\n\n          // If a caret trap was set by a mask function, we need to stop at the trap.\n          caretTrapIndexes.indexOf(i) !== -1 ||\n\n          // This is the beginning of the placeholder. We cannot move any further.\n          // Let's put the caret there.\n          i === 0\n        ) {\n          return i;\n        }\n      }\n    } else {\n      // Searching for the first placeholder or caret trap to the left\n\n      for (let i = startingSearchIndex; i >= 0; i--) {\n        // If we're deleting, we stop the caret right before the placeholder character.\n        // For example, for mask `(111) 11`, current conformed input `(456) 86`. If user\n        // modifies input to `(456 86`. That is, they deleted the `)`, we place the caret\n        // right after the first `6`\n\n        if (\n          // If we're deleting, we can position the caret right before the placeholder character\n          placeholder[i - 1] === placeholderChar ||\n\n          // If a caret trap was set by a mask function, we need to stop at the trap.\n          caretTrapIndexes.indexOf(i) !== -1 ||\n\n          // This is the beginning of the placeholder. We cannot move any further.\n          // Let's put the caret there.\n          i === 0\n        ) {\n          return i;\n        }\n      }\n    }\n  }\n}\n","import { adjustCaretPosition } from './adjustCaretPosition';\nimport { conformToMask } from './conformToMask';\nimport { convertMaskToPlaceholder, isString, isNumber, processCaretTraps, isArray, isMaskObject } from './utilities';\nimport { defaultPlaceholderChar } from './constants';\nimport { ConformConfig, Mask, MaskConfig, TextMaskState } from './typings';\n\nconst isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\nconst defer = typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame : setTimeout;\n\nexport function createTextMaskInputElement(config?: MaskConfig): any {\n  // Anything that we will need to keep between `update` calls, we will store in this `state` object.\n  const state: TextMaskState = {\n    previousConformedValue: undefined,\n    previousPlaceholder: undefined\n  };\n\n  return {\n    state,\n\n    // `update` is called by framework components whenever they want to update the `value` of the input element.\n    // The caller can send a `rawValue` to be conformed and set on the input element. However, the default use-case\n    // is for this to be read from the `inputElement` directly.\n    update(rawValue: any, {\n      inputElement,\n      mask: providedMask,\n      guide,\n      pipe,\n      placeholderChar = defaultPlaceholderChar,\n      keepCharPositions = false,\n      showMask = false\n    } = config): void {\n      // if `rawValue` is `undefined`, read from the `inputElement`\n      if (typeof rawValue === 'undefined') {\n        rawValue = inputElement.value;\n      }\n\n      // If `rawValue` equals `state.previousConformedValue`, we don't need to change anything. So, we return.\n      // This check is here to handle controlled framework components that repeat the `update` call on every render.\n      if (rawValue === state.previousConformedValue) { return; }\n\n      // We don't know what the mask would be yet. If it is an array, we take it as is, but if it's a function, we will\n      // have to call that function to get the mask array.\n      let mask: Mask;\n\n      // Text Mask accepts masks that are a combination of a `mask` and a `pipe` that work together. If such a `mask` is\n      // passed, we destructure it below, so the rest of the code can work normally as if a separate `mask` and a `pipe`\n      // were passed.\n      if (isMaskObject(providedMask)) {\n        pipe = providedMask.pipe;\n        providedMask = providedMask.mask;\n      }\n\n      // The `placeholder` is an essential piece of how Text Mask works. For a mask like `(111)`, the placeholder would\n      // be `(___)` if the `placeholderChar` is set to `_`.\n      let placeholder = '';\n\n      // If the provided mask is an array, we can call `convertMaskToPlaceholder` here once and we'll always have the\n      // correct `placeholder`.\n      if (providedMask instanceof Array) {\n        placeholder = convertMaskToPlaceholder(providedMask, placeholderChar);\n      }\n\n      // In framework components that support reactivity, it's possible to turn off masking by passing\n      // `false` for `mask` after initialization. See https://github.com/text-mask/text-mask/pull/359\n      if (!providedMask) {\n        return;\n      }\n\n      // We check the provided `rawValue` before moving further.\n      // If it's something we can't work with `getSafeRawValue` will throw.\n      const safeRawValue = getSafeRawValue(rawValue);\n\n      // `selectionEnd` indicates to us where the caret position is after the user has typed into the input\n      const { selectionEnd: currentCaretPosition } = inputElement;\n\n      // We need to know what the `previousConformedValue` and `previousPlaceholder` is from the previous `update` call\n      const { previousConformedValue, previousPlaceholder } = state;\n\n      let caretTrapIndexes: number[] = [];\n\n      // If the `providedMask` is a function. We need to call it at every `update` to get the `mask` array.\n      // Then we also need to get the `placeholder`\n      if (typeof providedMask === 'function') {\n        mask = providedMask(safeRawValue, { currentCaretPosition, previousConformedValue, placeholderChar });\n\n        // disable masking if `mask` is `false`\n        if (!mask) {\n          return;\n        }\n\n        // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n        // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask and return\n        // the indexes of the caret traps.\n        caretTrapIndexes = processCaretTraps(mask);\n\n        placeholder = convertMaskToPlaceholder(mask, placeholderChar);\n\n      } else {\n        // if the `providedMask` is not a function, we just use it as-is.\n        mask = providedMask;\n      }\n\n      // The following object will be passed to `conformToMask` to determine how the `rawValue` will be conformed\n      const conformToMaskConfig: ConformConfig = {\n        previousConformedValue,\n        guide,\n        placeholder,\n        placeholderChar,\n        pipe,\n        currentCaretPosition,\n        keepCharPositions\n      };\n\n      // `conformToMask` returns `conformedValue` as part of an object for future API flexibility\n      const { conformedValue } = conformToMask(safeRawValue, mask, conformToMaskConfig);\n\n      // The following few lines are to support the `pipe` feature.\n      let pipeResults: any = {};\n\n      // we need to know which conformed value to use, the one returned by the pipe or the one\n      // returned by `conformToMask`.\n      let finalConformedValue: any = conformedValue;\n\n      // If `pipe` is a function, we call it.\n      if (typeof pipe === 'function') {\n        // `pipe` receives the `conformedValue` and the configurations with which `conformToMask` was called.\n        pipeResults = pipe(conformedValue, { rawValue: safeRawValue, ...conformToMaskConfig});\n\n        // `pipeResults` should be an object. But as a convenience, we allow the pipe author to just return `false` to\n        // indicate rejection. Or return just a string when there are no piped characters.\n        // If the `pipe` returns `false` or a string, the block below turns it into an object that the rest\n        // of the code can work with.\n        if (pipeResults === false) {\n          // If the `pipe` rejects `conformedValue`, we use the `previousConformedValue`, and set `rejected` to `true`.\n          pipeResults = {value: previousConformedValue, rejected: true};\n          finalConformedValue = previousConformedValue;\n        } else if (isString(pipeResults)) {\n          pipeResults = {value: pipeResults};\n          finalConformedValue = pipeResults;\n        }\n      }\n\n      // After determining the conformed value, we will need to know where to set\n      // the caret position. `adjustCaretPosition` will tell us.\n      const adjustedCaretPosition = adjustCaretPosition({\n        previousConformedValue,\n        previousPlaceholder,\n        conformedValue: finalConformedValue,\n        placeholder,\n        rawValue: safeRawValue,\n        currentCaretPosition: currentCaretPosition || 0,\n        placeholderChar,\n        indexesOfPipedChars: pipeResults.indexesOfPipedChars,\n        caretTrapIndexes\n      });\n\n      // Text Mask sets the input value to an empty string when the condition below is set. It provides a better UX.\n      const inputValueShouldBeEmpty = finalConformedValue === placeholder\n        && (adjustedCaretPosition === 0 || adjustedCaretPosition === placeholder.length - 1);\n      const emptyValue = showMask ? placeholder : '';\n      const inputElementValue = (inputValueShouldBeEmpty) ? emptyValue : finalConformedValue;\n\n      state.previousConformedValue = inputElementValue; // store value for access for next time\n      state.previousPlaceholder = placeholder;\n\n      // In some cases, this `update` method will be repeatedly called with a raw value that has already been conformed\n      // and set to `inputElement.value`. The below check guards against needlessly readjusting the input state.\n      // See https://github.com/text-mask/text-mask/issues/231\n      if (inputElement.value === inputElementValue) {\n        return;\n      }\n\n      inputElement.value = inputElementValue; // set the input value\n      safeSetSelection(inputElement, adjustedCaretPosition); // adjust caret position\n    }\n  };\n}\n\nfunction safeSetSelection(element: HTMLInputElement, selectionPosition?: number | void): void {\n  if (document.activeElement === element && isNumber(selectionPosition)) {\n    if (isAndroid) {\n      defer(() => element.setSelectionRange(selectionPosition, selectionPosition, 'none'));\n    } else {\n      element.setSelectionRange(selectionPosition, selectionPosition, 'none');\n    }\n  }\n}\n\nfunction getSafeRawValue(inputValue: any): string {\n  if (isString(inputValue)) {\n    return inputValue;\n  } else if (isNumber(inputValue)) {\n    return String(inputValue);\n  } else if (inputValue === undefined || inputValue === null) {\n    return '';\n  } else {\n    throw new Error(\n      'The \\'value\\' provided to Text Mask needs to be a string or a number. The value ' +\n      `received was:\\n\\n ${JSON.stringify(inputValue)}`\n    );\n  }\n}\n","import { Directive, ElementRef, forwardRef, Input, Inject, NgModule, OnChanges, Optional, Provider, Renderer2, SimpleChanges } from '@angular/core';\nimport { NG_VALUE_ACCESSOR, ControlValueAccessor, COMPOSITION_BUFFER_MODE } from '@angular/forms';\nimport { ɵgetDOM as getDOM } from '@angular/platform-browser';\nimport { createTextMaskInputElement, TextMaskConfig } from './core';\n\nexport const MASKEDINPUT_VALUE_ACCESSOR: Provider = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MaskedInputDirective),\n  multi: true\n};\n\n/**\n * We must check whether the agent is Android because composition events\n * behave differently between iOS and Android.\n */\nfunction _isAndroid(): boolean {\n  const userAgent = getDOM() ? getDOM().getUserAgent() : '';\n  return /android (\\d+)/.test(userAgent.toLowerCase());\n}\n\n@Directive({\n  host: {\n    '(input)': '_handleInput($event.target.value)',\n    '(blur)': 'onTouched()',\n    '(compositionstart)': '_compositionStart()',\n    '(compositionend)': '_compositionEnd($event.target.value)'\n  },\n  selector: '[textMask]',\n  exportAs: 'textMask',\n  providers: [MASKEDINPUT_VALUE_ACCESSOR]\n})\nexport class MaskedInputDirective implements ControlValueAccessor, OnChanges {\n  @Input('textMask') textMaskConfig: TextMaskConfig = {\n    mask: [],\n    guide: true,\n    placeholderChar: '_',\n    pipe: undefined,\n    keepCharPositions: false,\n  };\n\n  private textMaskInputElement: any;\n  private inputElement!: HTMLInputElement;\n\n  /** Whether the user is creating a composition string (IME events). */\n  private composing = false;\n\n  onChange = (_: any) => {};\n  onTouched = () => {};\n\n  constructor(\n    private renderer: Renderer2,\n    private elementRef: ElementRef,\n    @Optional() @Inject(COMPOSITION_BUFFER_MODE) private compositionMode: boolean\n  ) {\n    if (this.compositionMode == null) {\n      this.compositionMode = !_isAndroid();\n    }\n  }\n\n  ngOnChanges(): void {\n    this._setupMask(true);\n\n    if (this.textMaskInputElement !== undefined) {\n      this.textMaskInputElement.update(this.inputElement.value);\n    }\n  }\n\n  writeValue(value: any): void {\n    this._setupMask();\n\n    // set the initial value for cases where the mask is disabled\n    const normalizedValue = value == null ? '' : value;\n    this.renderer.setProperty(this.inputElement, 'value', normalizedValue);\n\n    if (this.textMaskInputElement !== undefined) {\n      this.textMaskInputElement.update(value);\n    }\n  }\n\n  registerOnChange(fn: (_: any) => void): void {\n    this.onChange = fn;\n  }\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);\n  }\n\n  _handleInput(value: string): void {\n    if (!this.compositionMode || (this.compositionMode && !this.composing)) {\n      this._setupMask();\n\n      if (this.textMaskInputElement !== undefined) {\n        this.textMaskInputElement.update(value);\n\n        // get the updated value\n        value = this.inputElement.value;\n        this.onChange(value);\n      }\n    }\n  }\n\n  _setupMask(create = false): void {\n    if (!this.inputElement) {\n      if (this.elementRef.nativeElement.tagName.toUpperCase() === 'INPUT') {\n        // `textMask` directive is used directly on an input element\n        this.inputElement = this.elementRef.nativeElement;\n      } else {\n        // `textMask` directive is used on an abstracted input element, `md-input-container`, etc\n        this.inputElement = this.elementRef.nativeElement.getElementsByTagName('INPUT')[0];\n      }\n    }\n\n    if (this.inputElement && create) {\n      this.textMaskInputElement = createTextMaskInputElement(\n        Object.assign({ inputElement: this.inputElement }, this.textMaskConfig)\n      );\n    }\n  }\n\n  _compositionStart(): void {\n    this.composing = true;\n  }\n\n  _compositionEnd(value: any): void {\n    this.composing = false;\n\n    if (this.compositionMode) {\n      this._handleInput(value);\n    }\n  }\n}\n\n@NgModule({\n  declarations: [MaskedInputDirective],\n  exports: [MaskedInputDirective]\n})\nexport class TextMaskModule {}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":["err","getDOM"],"mappings":"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"}